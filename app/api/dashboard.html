<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>URL Security Scanner | Azure DevSecOps</title>
  <meta name="description" content="Analyze URLs for security threats, phishing indicators, and web vulnerabilities." />
  <meta name="theme-color" content="#0b1020" media="(prefers-color-scheme: dark)" />
  <meta name="theme-color" content="#f6f7fb" media="(prefers-color-scheme: light)" />
  <style>
    :root {
      color-scheme: light dark;
      --bg: #f6f7fb;
      --card: #ffffff;
      --text: #111827;
      --muted: #6b7280;
      --border: #e5e7eb;
      --shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
      --shadow-sm: 0 8px 22px rgba(0, 0, 0, 0.06);
      --primary: #2563eb;
      --primary-ink: #ffffff;
      --success: #16a34a;
      --success-ink: #ffffff;
      --success-soft: rgba(22, 163, 74, 0.14);
      --danger: #dc2626;
      --danger-soft: rgba(220, 38, 38, 0.14);
      --code-bg: #0b1020;
      --code-fg: #d6e0ff;
      --ring: rgba(37, 99, 235, 0.22);
      --primary-soft: rgba(37, 99, 235, 0.12);
      --primary-soft-border: rgba(37, 99, 235, 0.45);
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --bg: #0b1020;
        --card: #0f172a;
        --text: #e5e7eb;
        --muted: #94a3b8;
        --border: #22304a;
        --shadow: 0 14px 40px rgba(0, 0, 0, 0.35);
        --shadow-sm: 0 10px 28px rgba(0, 0, 0, 0.28);
        --primary: #60a5fa;
        --primary-ink: #0b1020;
        --success: #4ade80;
        --success-ink: #0b1020;
        --success-soft: rgba(74, 222, 128, 0.16);
        --danger: #fb7185;
        --danger-soft: rgba(251, 113, 133, 0.16);
        --code-bg: #070b18;
        --code-fg: #d6e0ff;
        --ring: rgba(96, 165, 250, 0.26);
        --primary-soft: rgba(96, 165, 250, 0.14);
        --primary-soft-border: rgba(96, 165, 250, 0.45);
      }
    }

    /* Animations */
    @keyframes spin {
      from {
        transform: rotate(0deg);
      }

      to {
        transform: rotate(360deg);
      }
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(-8px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes fadeOut {
      from {
        opacity: 1;
        transform: translateY(0);
      }

      to {
        opacity: 0;
        transform: translateY(-8px);
      }
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateX(100%);
      }

      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    @keyframes slideOut {
      from {
        opacity: 1;
        transform: translateX(0);
      }

      to {
        opacity: 0;
        transform: translateX(100%);
      }
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.5;
      }
    }

    @keyframes shimmer {
      0% {
        background-position: -200% 0;
      }

      100% {
        background-position: 200% 0;
      }
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background:
        radial-gradient(1200px circle at 15% 5%, rgba(37, 99, 235, 0.16), transparent 55%),
        radial-gradient(900px circle at 85% 18%, rgba(22, 163, 74, 0.10), transparent 55%),
        var(--bg);
      color: var(--text);
      line-height: 1.45;
      min-height: 100vh;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    /* Skip to main content link for accessibility */
    .skip-link {
      position: absolute;
      top: -100%;
      left: 0;
      padding: 0.75rem 1.25rem;
      background: var(--primary);
      color: var(--primary-ink);
      font-weight: 700;
      z-index: 9999;
      border-radius: 0 0 10px 0;
      transition: top 0.2s ease;
    }

    .skip-link:focus {
      top: 0;
      outline: none;
      box-shadow: 0 0 0 4px var(--ring);
    }

    /* Toast notification container */
    .toast-container {
      position: fixed;
      top: calc(1rem + env(safe-area-inset-top));
      right: calc(1rem + env(safe-area-inset-right));
      z-index: 10000;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      pointer-events: none;
      max-width: min(380px, calc(100vw - 2rem));
    }

    .toast {
      display: flex;
      align-items: center;
      gap: 0.65rem;
      padding: 0.75rem 1rem;
      border-radius: 12px;
      background: var(--card);
      border: 1px solid var(--border);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
      pointer-events: auto;
      animation: slideIn 0.25s ease forwards;
      font-size: 0.9rem;
      font-weight: 500;
    }

    .toast.toast-out {
      animation: slideOut 0.2s ease forwards;
    }

    .toast-icon {
      flex: 0 0 auto;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 999px;
      font-size: 0.75rem;
      font-weight: 900;
    }

    .toast.toast-success .toast-icon {
      background: var(--success-soft);
      color: var(--success);
    }

    .toast.toast-error .toast-icon {
      background: var(--danger-soft);
      color: var(--danger);
    }

    .toast.toast-info .toast-icon {
      background: var(--primary-soft);
      color: var(--primary);
    }

    .toast.toast-warn .toast-icon {
      background: rgba(234, 179, 8, 0.14);
      color: rgba(234, 179, 8, 1);
    }

    .toast-message {
      flex: 1;
      min-width: 0;
    }

    .toast-close {
      flex: 0 0 auto;
      padding: 0.25rem;
      border: none;
      background: transparent;
      color: var(--muted);
      cursor: pointer;
      border-radius: 6px;
      transition: background 0.15s ease;
    }

    .toast-close:hover {
      background: rgba(148, 163, 184, 0.12);
    }

    /* Loading spinner */
    .spinner {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid currentColor;
      border-top-color: transparent;
      border-radius: 50%;
      animation: spin 0.7s linear infinite;
      vertical-align: middle;
    }

    .spinner-sm {
      width: 14px;
      height: 14px;
      border-width: 2px;
    }

    .spinner-lg {
      width: 24px;
      height: 24px;
      border-width: 3px;
    }

    /* Button loading state */
    button.loading {
      position: relative;
      color: transparent !important;
      pointer-events: none;
    }

    button.loading::after {
      content: "";
      position: absolute;
      top: 50%;
      left: 50%;
      width: 16px;
      height: 16px;
      margin: -8px 0 0 -8px;
      border: 2px solid currentColor;
      border-color: var(--primary-ink);
      border-top-color: transparent;
      border-radius: 50%;
      animation: spin 0.7s linear infinite;
    }

    button:not(.primary).loading::after {
      border-color: var(--text);
      border-top-color: transparent;
    }

    /* Skeleton loading */
    .skeleton {
      background: linear-gradient(90deg, rgba(148, 163, 184, 0.08) 25%, rgba(148, 163, 184, 0.16) 50%, rgba(148, 163, 184, 0.08) 75%);
      background-size: 200% 100%;
      animation: shimmer 1.5s infinite;
      border-radius: 8px;
    }

    /* Keyboard shortcut hint */
    .kbd {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 1.5em;
      padding: 0.15rem 0.4rem;
      font-size: 0.72rem;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-weight: 700;
      color: var(--muted);
      background: rgba(148, 163, 184, 0.1);
      border: 1px solid var(--border);
      border-radius: 5px;
      box-shadow: 0 1px 0 rgba(0, 0, 0, 0.1);
    }

    a {
      color: var(--primary);
    }

    code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
    }

    .app {
      max-width: 1920px;
      margin: 0 auto;
      padding: clamp(1.25rem, 2vw, 2rem) clamp(1.5rem, 2vw, 3rem) 3rem;
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .header h1 {
      margin: 0;
      font-size: 1.65rem;
      letter-spacing: -0.02em;
    }

    .sub {
      margin: 0.35rem 0 0;
      color: var(--muted);
      line-height: 1.4;
    }

    .grid {
      margin-top: 1.25rem;
      display: grid;
      grid-template-columns: minmax(320px, 380px) 1fr;
      gap: 1.15rem;
      align-items: start;
    }

    @media (max-width: 980px) {
      .grid {
        grid-template-columns: 1fr;
      }
    }

    .card {
      background: linear-gradient(180deg, rgba(148, 163, 184, 0.06), rgba(148, 163, 184, 0.02)), var(--card);
      border: 1px solid var(--border);
      border-radius: 14px;
      box-shadow: var(--shadow);
      padding: 1rem;
    }

    .card.full {
      grid-column: 1 / -1;
    }

    .card h2 {
      margin: 0 0 0.75rem;
      font-size: 1.05rem;
    }

    .card-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.75rem;
      flex-wrap: wrap;
      margin-bottom: 0.75rem;
    }

    .card-head h2 {
      margin: 0;
    }

    .field {
      margin-bottom: 0.9rem;
    }

    label {
      display: block;
      font-size: 0.85rem;
      color: var(--muted);
      margin-bottom: 0.35rem;
    }

    input {
      width: 100%;
      padding: 0.65rem 0.75rem;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(148, 163, 184, 0.06);
      color: var(--text);
      transition: box-shadow 120ms ease, border-color 120ms ease, background 120ms ease;
    }

    input::placeholder {
      color: var(--muted);
      opacity: 0.75;
    }

    input:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 4px var(--ring);
      background: rgba(148, 163, 184, 0.04);
    }

    .url-group {
      display: flex;
      width: 100%;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(148, 163, 184, 0.06);
      overflow: hidden;
      transition: box-shadow 120ms ease, border-color 120ms ease, background 120ms ease;
    }

    .url-scheme {
      display: inline-flex;
      align-items: center;
      padding: 0.65rem 0.75rem;
      font-weight: 700;
      color: var(--success-ink);
      background: var(--success);
      border-right: 1px solid rgba(0, 0, 0, 0.18);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      white-space: nowrap;
    }

    .url-input {
      flex: 1 1 auto;
      border: none;
      background: transparent;
      padding: 0.65rem 0.75rem;
      width: auto;
    }

    .url-input:focus,
    .url-input:focus-visible {
      outline: none;
      box-shadow: none;
      background: transparent;
    }

    .url-group:focus-within {
      border-color: var(--primary);
      box-shadow: 0 0 0 4px var(--ring);
      background: rgba(148, 163, 184, 0.04);
    }

    .url-group:focus-within .url-scheme {
      border-right-color: var(--primary-soft-border);
    }

    /* API key input with toggle */
    .api-key-group {
      display: flex;
      width: 100%;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(148, 163, 184, 0.06);
      overflow: hidden;
      transition: box-shadow 120ms ease, border-color 120ms ease, background 120ms ease;
    }

    .api-key-group:focus-within {
      border-color: var(--primary);
      box-shadow: 0 0 0 4px var(--ring);
      background: rgba(148, 163, 184, 0.04);
    }

    .api-key-input {
      flex: 1 1 auto;
      border: none;
      background: transparent;
      padding: 0.65rem 0.75rem;
      width: auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      letter-spacing: 0.02em;
    }

    .api-key-input:focus,
    .api-key-input:focus-visible {
      outline: none;
      box-shadow: none;
      background: transparent;
    }

    .api-key-toggle {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0 0.75rem;
      border: none;
      background: rgba(148, 163, 184, 0.08);
      color: var(--muted);
      cursor: pointer;
      transition: background 120ms ease, color 120ms ease;
      font-size: 1rem;
    }

    .api-key-toggle:hover {
      background: rgba(148, 163, 184, 0.15);
      color: var(--text);
    }

    .api-key-saved {
      display: inline-flex;
      align-items: center;
      padding: 0 0.6rem;
      color: var(--success-ink);
      background: var(--success);
      font-size: 0.85rem;
    }

    .help {
      margin-top: 0.35rem;
      font-size: 0.85rem;
      color: var(--muted);
    }

    .actions {
      display: flex;
      gap: 0.6rem;
      flex-wrap: wrap;
      align-items: center;
    }

    button {
      border: 1px solid var(--border);
      background: transparent;
      color: var(--text);
      padding: 0.6rem 0.85rem;
      border-radius: 10px;
      cursor: pointer;
      transition: transform 80ms ease, background 120ms ease, border-color 120ms ease, opacity 120ms ease;
    }

    button:hover:not(:disabled) {
      background: rgba(148, 163, 184, 0.08);
      transform: translateY(-1px);
    }

    button.primary {
      background: var(--primary);
      border-color: var(--primary);
      color: var(--primary-ink);
      font-weight: 600;
    }

    button.primary:hover:not(:disabled) {
      filter: brightness(1.03);
    }

    button:focus-visible,
    .tab:focus-visible,
    input:focus-visible {
      outline: none;
      box-shadow: 0 0 0 4px var(--ring);
    }

    button:disabled {
      opacity: 0.55;
      cursor: not-allowed;
    }

    .status {
      margin-top: 0.85rem;
      min-height: 1.25rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      color: var(--muted);
    }

    .badge {
      font-size: 0.75rem;
      padding: 0.2rem 0.55rem;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: transparent;
      color: var(--text);
      font-weight: 600;
    }

    .badge.ok {
      border-color: rgba(22, 163, 74, 0.5);
      background: rgba(22, 163, 74, 0.12);
    }

    .badge.warn {
      border-color: rgba(234, 179, 8, 0.6);
      background: rgba(234, 179, 8, 0.14);
    }

    .badge.bad {
      border-color: rgba(220, 38, 38, 0.5);
      background: rgba(220, 38, 38, 0.12);
    }

    .badge.info {
      border-color: var(--primary-soft-border);
      background: var(--primary-soft);
    }

    .muted {
      color: var(--muted);
    }

    .small {
      font-size: 0.85rem;
    }

    .timestamp-cell {
      font-size: 0.9rem;
      font-variant-numeric: tabular-nums;
      color: var(--muted);
      white-space: nowrap;
    }

    /* Eye icon for API key toggle */
    .eye-icon {
      width: 18px;
      height: 18px;
      stroke: currentColor;
      stroke-width: 2;
      fill: none;
    }

    pre {
      margin: 0;
      background: var(--code-bg);
      color: var(--code-fg);
      padding: 1rem;
      border-radius: 12px;
      overflow: auto;
      border: 1px solid var(--border);
      font-size: 0.9rem;
      line-height: 1.45;
    }

    .table-wrap {
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: rgba(148, 163, 184, 0.03);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      min-width: 720px;
    }

    th,
    td {
      text-align: left;
      padding: 0.55rem 0.65rem;
      border-bottom: 1px solid var(--border);
      vertical-align: top;
    }

    th {
      font-size: 0.78rem;
      letter-spacing: 0.02em;
      text-transform: uppercase;
      color: var(--muted);
      background: rgba(148, 163, 184, 0.10);
      position: sticky;
      top: 0;
    }

    tr:last-child td {
      border-bottom: none;
    }

    tbody tr {
      transition: background 100ms ease;
    }

    tbody tr:hover {
      background: rgba(148, 163, 184, 0.06);
    }

    .job-id-cell {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
    }

    .copy-job-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.2rem;
      border: none;
      background: transparent;
      color: var(--muted);
      cursor: pointer;
      border-radius: 4px;
      transition: background 100ms ease, color 100ms ease;
      font-size: 0.75rem;
    }

    .copy-job-btn:hover {
      background: rgba(148, 163, 184, 0.15);
      color: var(--text);
    }

    .copy-job-btn.copied {
      color: var(--success-ink);
    }

    .nowrap {
      white-space: nowrap;
    }

    .url-cell {
      max-width: 340px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    @media (max-width: 720px) {
      .table-wrap {
        border: 0;
        background: transparent;
      }

      table {
        min-width: 0;
      }

      thead {
        display: none;
      }

      tbody {
        display: block;
      }

      tr {
        display: block;
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 0.75rem;
        margin-bottom: 0.65rem;
        background: rgba(148, 163, 184, 0.03);
      }

      td {
        display: block;
        border-bottom: 0;
        padding: 0.35rem 0;
      }

      td[data-label] {
        display: grid;
        grid-template-columns: minmax(86px, 120px) 1fr;
        gap: 0.65rem;
        align-items: start;
      }

      td[data-label]::before {
        content: attr(data-label);
        font-size: 0.72rem;
        letter-spacing: 0.06em;
        text-transform: uppercase;
        color: var(--muted);
        font-weight: 700;
        padding-top: 0.12rem;
      }

      td.nowrap {
        white-space: normal;
      }

      td[colspan] {
        text-align: center;
        padding: 0.85rem 0;
      }

      .url-cell {
        max-width: none;
        white-space: normal;
        overflow: visible;
        text-overflow: clip;
      }

      .url-cell a {
        overflow-wrap: anywhere;
        word-break: break-word;
      }
    }

    .filter {
      flex: 1;
      min-width: 220px;
    }

    .history-controls {
      display: flex;
      gap: 0.5rem;
      align-items: center;
      flex: 1;
      min-width: min(560px, 100%);
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    select.select {
      width: auto;
      min-width: 170px;
      padding: 0.65rem 0.75rem;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(148, 163, 184, 0.06);
      color: var(--text);
      transition: box-shadow 120ms ease, border-color 120ms ease, background 120ms ease;
    }

    select.select:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 4px var(--ring);
      background: rgba(148, 163, 184, 0.04);
    }

    .history-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 0.65rem;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: rgba(148, 163, 184, 0.03);
      padding: 0.65rem;
      min-height: 148px;
    }

    .job-card {
      border: 1px solid rgba(148, 163, 184, 0.22);
      border-radius: 12px;
      background: rgba(148, 163, 184, 0.05);
      padding: 0.6rem 0.65rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      min-height: 120px;
    }

    .job-card-top {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
    }

    .job-url {
      display: block;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      text-decoration: none;
      color: var(--text);
      font-weight: 650;
    }

    .job-url:hover {
      text-decoration: underline;
      color: var(--primary);
    }

    .job-meta {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      color: var(--muted);
      font-variant-numeric: tabular-nums;
      font-size: 0.8rem;
    }

    .job-actions {
      display: flex;
      gap: 0.45rem;
      flex-wrap: wrap;
    }

    .job-actions button {
      padding: 0.35rem 0.55rem;
      font-size: 0.82rem;
    }

    .badge-row {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      flex-wrap: wrap;
    }

    .history-pager {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      margin-top: 0.75rem;
      flex-wrap: wrap;
    }

    .tabs {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      margin: 0.25rem 0 0.85rem;
    }

    .tab {
      border: 1px solid var(--border);
      background: transparent;
      color: var(--text);
      padding: 0.45rem 0.7rem;
      border-radius: 999px;
      cursor: pointer;
      font-size: 0.85rem;
    }

    .tab[aria-selected="true"] {
      background: var(--primary-soft);
      border-color: var(--primary-soft-border);
    }

    .tab[aria-current="page"] {
      background: var(--primary-soft);
      border-color: var(--primary-soft-border);
    }

    a.tab {
      text-decoration: none;
      display: inline-flex;
      align-items: center;
    }

    .panel.hidden {
      display: none;
    }

    .summary-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 1rem;
      align-items: start;
    }

    .summary-col {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      min-width: 0;
    }

    @media (max-width: 900px) {
      .summary-grid {
        grid-template-columns: 1fr;
      }
    }

    .summary-block {
      --dot: var(--primary);
      --dot-soft: var(--primary-soft);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 0.95rem;
      background: rgba(148, 163, 184, 0.04);
      backdrop-filter: blur(10px);
      align-self: start;
      height: fit-content;
      min-width: 0;
    }

    .summary-block.span-all {
      grid-column: 1 / -1;
    }

    .summary-block.tone-ok {
      --dot: var(--success);
      --dot-soft: var(--success-soft);
    }

    .summary-block.tone-warn {
      --dot: rgba(234, 179, 8, 1);
      --dot-soft: rgba(234, 179, 8, 0.14);
    }

    .summary-block.tone-bad {
      --dot: var(--danger);
      --dot-soft: var(--danger-soft);
    }

    .summary-block h3 {
      margin: 0 0 0.75rem;
      font-size: 0.95rem;
      display: flex;
      align-items: center;
      gap: 0.55rem;
      padding-bottom: 0.55rem;
      border-bottom: 1px solid rgba(148, 163, 184, 0.14);
    }

    .summary-block h3::before {
      content: "";
      width: 10px;
      height: 10px;
      border-radius: 999px;
      background: var(--dot);
      box-shadow: 0 0 0 4px var(--dot-soft);
      opacity: 0.9;
      flex: 0 0 auto;
    }

    .summary-title {
      font-weight: 700;
      letter-spacing: -0.01em;
    }

    .summary-meta {
      margin-left: auto;
      display: inline-flex;
      flex-wrap: wrap;
      gap: 0.35rem;
      justify-content: flex-end;
    }

    dl.kv {
      display: block;
      margin: 0;
    }

    dl.kv.kv-wide .kv-row {
      grid-template-columns: 1fr;
    }

    dl.kv.kv-wide dt {
      display: none;
    }

    dl.kv .kv-row {
      display: grid;
      grid-template-columns: minmax(120px, 170px) 1fr;
      gap: 0.35rem 0.8rem;
      padding: 0.4rem 0;
    }

    dl.kv .kv-row>* {
      min-width: 0;
    }

    dl.kv .kv-row+.kv-row {
      border-top: 1px solid rgba(148, 163, 184, 0.14);
    }

    dl.kv dt {
      color: var(--muted);
      font-size: 0.72rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      padding-top: 0.12rem;
    }

    dl.kv dd {
      margin: 0;
      min-width: 0;
      overflow-wrap: anywhere;
      font-weight: 500;
      font-variant-numeric: tabular-nums;
      line-height: 1.35;
    }

    @media (max-width: 520px) {
      dl.kv .kv-row {
        grid-template-columns: 1fr;
        gap: 0.2rem;
      }

      dl.kv dt {
        padding-top: 0;
      }

      .app {
        padding: 1rem 1rem 2rem;
      }

      .header {
        flex-direction: column;
        align-items: stretch;
      }

      .header h1 {
        font-size: 1.45rem;
      }

      .header .actions {
        width: 100%;
        flex-direction: column;
        align-items: stretch;
      }

      .header .actions>button,
      .header .actions>a {
        width: 100%;
      }

      .header .actions>a.tab {
        justify-content: center;
      }

      .card .actions {
        flex-direction: column;
        align-items: stretch;
      }

      .card .actions>button {
        width: 100%;
      }

      .history-controls {
        justify-content: stretch;
      }

      .history-controls .filter {
        min-width: 0;
        flex: 1 1 100%;
      }

      .history-controls .select {
        width: 100%;
        min-width: 0;
      }

      .url-group {
        flex-wrap: wrap;
      }

      .url-scheme {
        width: 100%;
        justify-content: center;
        border-right: none;
        border-bottom: 1px solid rgba(0, 0, 0, 0.18);
      }

      .url-input {
        width: 100%;
      }

      .toast-container {
        top: auto;
        bottom: calc(1rem + env(safe-area-inset-bottom));
        right: auto;
        left: 50%;
        transform: translateX(-50%);
        max-width: min(520px, calc(100vw - 2rem));
      }
    }

    .value-inline {
      display: inline-flex;
      gap: 0.35rem;
      flex-wrap: wrap;
      align-items: center;
    }

    .value-row {
      display: flex;
      align-items: flex-start;
      gap: 0.5rem;
      justify-content: space-between;
      width: 100%;
    }

    .value-row> :first-child {
      flex: 1 1 auto;
      min-width: 0;
    }

    .value-row .icon-btn {
      flex: 0 0 auto;
    }

    .value-code {
      display: inline-block;
      padding: 0.18rem 0.45rem;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.22);
      background: rgba(148, 163, 184, 0.08);
      font-size: 0.86rem;
      line-height: 1.2;
      white-space: pre-wrap;
      word-break: break-word;
    }

    /* HTTP status code colors */
    .value-code.status-ok {
      background: var(--success-soft);
      border-color: rgba(22, 163, 74, 0.4);
      color: var(--success);
    }

    .value-code.status-warn {
      background: rgba(234, 179, 8, 0.14);
      border-color: rgba(234, 179, 8, 0.4);
      color: rgba(234, 179, 8, 1);
    }

    .value-code.status-bad {
      background: var(--danger-soft);
      border-color: rgba(220, 38, 38, 0.4);
      color: var(--danger);
    }

    /* Timestamp styling */
    .timestamp-value {
      font-variant-numeric: tabular-nums;
      cursor: help;
    }

    .value-link {
      text-decoration: none;
      border-bottom: 1px dashed rgba(148, 163, 184, 0.45);
      overflow-wrap: anywhere;
      word-break: break-word;
    }

    .value-link:hover {
      border-bottom-color: var(--primary);
    }

    .icon-btn {
      padding: 0.3rem 0.55rem;
      border-radius: 10px;
      font-size: 0.78rem;
      line-height: 1;
      border: 1px solid rgba(148, 163, 184, 0.28);
      background: rgba(148, 163, 184, 0.08);
    }

    .icon-btn:hover:not(:disabled) {
      background: rgba(148, 163, 184, 0.14);
      transform: none;
    }

    /* --- Web analysis UI (Security Analysis / Page / Network) --- */
    .section {
      grid-column: 1 / -1;
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: clamp(1.1rem, 1.8vw, 1.5rem);
      background: linear-gradient(180deg, rgba(148, 163, 184, 0.06), rgba(148, 163, 184, 0.02));
      backdrop-filter: blur(10px);
      min-width: 0;
    }

    .section-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      flex-wrap: wrap;
      margin-bottom: 1rem;
      padding-bottom: 0.75rem;
      border-bottom: 1px solid rgba(148, 163, 184, 0.14);
    }

    .section-title {
      margin: 0;
      font-size: clamp(1.05rem, 1.2vw, 1.15rem);
      letter-spacing: -0.01em;
      font-weight: 800;
    }

    .analysis-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: clamp(0.85rem, 1.2vw, 1.25rem);
      align-items: start;
    }

    .analysis-grid .analysis-card {
      min-width: 0;
    }

    /* Allow certain cards to span 2 columns for better grouping */
    .analysis-grid .analysis-card.span-2 {
      grid-column: span 2;
    }

    @media (max-width: 1600px) {
      .analysis-grid {
        grid-template-columns: repeat(3, 1fr);
      }

      .analysis-grid .analysis-card.span-2 {
        grid-column: span 1;
      }
    }

    @media (max-width: 1200px) {
      .analysis-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    @media (max-width: 768px) {
      .analysis-grid {
        grid-template-columns: 1fr;
      }
    }

    /* Security Summary Stats Bar */
    .security-summary {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: clamp(1rem, 2vw, 2rem);
      padding: 0.85rem 1.25rem;
      margin-bottom: 1.25rem;
      background: linear-gradient(135deg, rgba(148, 163, 184, 0.08), rgba(148, 163, 184, 0.03));
      border: 1px solid rgba(148, 163, 184, 0.18);
      border-radius: 12px;
      flex-wrap: wrap;
    }

    .security-stat {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-weight: 700;
      font-size: 0.92rem;
    }

    .security-stat-icon {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      flex-shrink: 0;
    }

    .security-stat.stat-ok .security-stat-icon {
      background: var(--success);
      box-shadow: 0 0 0 4px var(--success-soft);
    }

    .security-stat.stat-warn .security-stat-icon {
      background: rgba(234, 179, 8, 1);
      box-shadow: 0 0 0 4px rgba(234, 179, 8, 0.14);
    }

    .security-stat.stat-bad .security-stat-icon {
      background: var(--danger);
      box-shadow: 0 0 0 4px var(--danger-soft);
    }

    .security-stat.stat-ok {
      color: var(--success);
    }

    .security-stat.stat-warn {
      color: rgba(234, 179, 8, 1);
    }

    .security-stat.stat-bad {
      color: var(--danger);
    }

    .security-stat-label {
      color: var(--muted);
      font-weight: 500;
    }

    /* Card group labels */
    .card-group-label {
      grid-column: 1 / -1;
      font-size: 0.8rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--muted);
      padding: 0.5rem 0 0.25rem;
      border-bottom: 1px solid rgba(148, 163, 184, 0.12);
      margin-bottom: 0.25rem;
    }

    .card-group-label:first-child {
      padding-top: 0;
    }

    .analysis-card {
      --dot: var(--primary);
      --dot-soft: var(--primary-soft);
      border: 1px solid rgba(148, 163, 184, 0.22);
      border-radius: 14px;
      padding: clamp(1rem, 1.3vw, 1.2rem);
      background: linear-gradient(180deg, rgba(148, 163, 184, 0.07), rgba(148, 163, 184, 0.02));
      box-shadow: var(--shadow-sm);
      display: flex;
      flex-direction: column;
      gap: 0.85rem;
      min-width: 0;
      transition: transform 80ms ease, border-color 120ms ease, box-shadow 120ms ease, background 120ms ease;
      overflow: hidden;
      position: relative;
    }

    .analysis-card.tone-ok {
      --dot: var(--success);
      --dot-soft: var(--success-soft);
      border-color: rgba(22, 163, 74, 0.5);
    }

    .analysis-card.tone-warn {
      --dot: rgba(234, 179, 8, 1);
      --dot-soft: rgba(234, 179, 8, 0.14);
      border-color: rgba(234, 179, 8, 0.6);
    }

    .analysis-card.tone-bad {
      --dot: var(--danger);
      --dot-soft: var(--danger-soft);
      border-color: rgba(220, 38, 38, 0.5);
    }

    .analysis-card:hover {
      transform: translateY(-1px);
      border-color: rgba(148, 163, 184, 0.35);
      background: linear-gradient(180deg, rgba(148, 163, 184, 0.08), rgba(148, 163, 184, 0.02));
    }

    .analysis-card.tone-ok:hover {
      border-color: rgba(22, 163, 74, 0.6);
    }

    .analysis-card.tone-warn:hover {
      border-color: rgba(234, 179, 8, 0.7);
    }

    .analysis-card.tone-bad:hover {
      border-color: rgba(220, 38, 38, 0.6);
    }

    .analysis-card:focus-within {
      outline: none;
      border-color: var(--primary-soft-border);
      box-shadow: var(--shadow-sm), 0 0 0 4px var(--ring);
    }

    .analysis-card h4 {
      margin: 0;
      font-size: 0.98rem;
      font-weight: 800;
      letter-spacing: -0.01em;
      display: flex;
      align-items: center;
      gap: 0.55rem;
      padding-bottom: 0.65rem;
      border-bottom: 1px solid rgba(148, 163, 184, 0.14);
    }

    .analysis-card h4::before {
      content: "";
      width: 10px;
      height: 10px;
      border-radius: 999px;
      background: var(--dot);
      box-shadow: 0 0 0 4px var(--dot-soft);
      opacity: 0.95;
      flex: 0 0 auto;
    }

    .checklist {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .checkline {
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.14);
      background: rgba(148, 163, 184, 0.03);
      transition: all 180ms cubic-bezier(0.4, 0, 0.2, 1);
      overflow: hidden;
    }

    .checkline summary {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.6rem;
      min-width: 0;
      padding: 0.45rem 0.55rem;
      cursor: pointer;
      user-select: none;
      list-style: none;
      border-radius: 10px;
    }

    .checkline summary::-webkit-details-marker {
      display: none;
    }

    .checkline summary:hover {
      background: rgba(148, 163, 184, 0.06);
    }

    .checkline summary:focus-visible {
      outline: none;
      box-shadow: 0 0 0 4px var(--ring);
      border-radius: 10px;
    }

    .checkline[open] {
      border-color: rgba(148, 163, 184, 0.28);
      background: rgba(148, 163, 184, 0.06);
      box-shadow: 0 2px 8px rgba(148, 163, 184, 0.12);
      transform: translateY(-1px);
    }

    .checkleft {
      display: inline-flex;
      align-items: center;
      gap: 0.55rem;
      min-width: 0;
    }

    .checkdot {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      background: var(--primary);
      box-shadow: 0 0 0 4px var(--primary-soft);
      flex: 0 0 auto;
      opacity: 0.95;
    }

    .checkline.ok .checkdot {
      background: var(--success);
      box-shadow: 0 0 0 4px var(--success-soft);
    }

    .checkline.bad .checkdot {
      background: var(--danger);
      box-shadow: 0 0 0 4px var(--danger-soft);
    }

    .checkline.warn .checkdot {
      background: rgba(234, 179, 8, 1);
      box-shadow: 0 0 0 4px rgba(234, 179, 8, 0.14);
    }

    .checklabel {
      font-weight: 700;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .checkvalue {
      font-weight: 700;
      font-variant-numeric: tabular-nums;
      color: var(--muted);
      flex: 0 0 auto;
    }

    .checkline.ok .checkvalue {
      color: var(--success);
    }

    .checkline.warn .checkvalue {
      color: rgba(234, 179, 8, 1);
    }

    .checkline.bad .checkvalue {
      color: var(--danger);
    }

    .checkhint {
      margin-left: 0.35rem;
      font-size: 0.75rem;
      font-weight: 900;
      color: var(--muted);
      border: 1px solid rgba(148, 163, 184, 0.28);
      background: rgba(148, 163, 184, 0.08);
      padding: 0;
      border-radius: 999px;
      line-height: 1;
      width: 1.1rem;
      height: 1.1rem;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      flex: 0 0 auto;
      opacity: 0.95;
    }

    .checkhelp {
      margin: 0.45rem 0 0.25rem;
      margin-left: 1.65rem;
      padding: 0.65rem 0.75rem;
      color: var(--muted);
      font-size: 0.83rem;
      line-height: 1.45;
      border-left: 3px solid rgba(148, 163, 184, 0.25);
      background: linear-gradient(90deg, rgba(148, 163, 184, 0.06), rgba(148, 163, 184, 0.02));
      border-radius: 8px;
      transition: all 120ms ease;
      backdrop-filter: blur(4px);
    }

    .checkline.ok .checkhelp {
      border-left-color: rgba(22, 163, 74, 0.6);
    }

    .checkline.warn .checkhelp {
      border-left-color: rgba(234, 179, 8, 0.7);
    }

    .checkline.bad .checkhelp {
      border-left-color: rgba(220, 38, 38, 0.6);
    }

    .checkline .mini-toggle {
      margin: 0.45rem 0 0.15rem;
      margin-left: 1.65rem;
    }

    .headers-list.evidence-list {
      max-height: 240px;
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: rgba(148, 163, 184, 0.3) transparent;
      border: 1px solid rgba(148, 163, 184, 0.15);
      border-radius: 8px;
      background: linear-gradient(180deg, rgba(148, 163, 184, 0.04), rgba(148, 163, 184, 0.01));
    }

    .headers-list.evidence-list::-webkit-scrollbar {
      width: 6px;
    }

    .headers-list.evidence-list::-webkit-scrollbar-track {
      background: rgba(148, 163, 184, 0.08);
      border-radius: 3px;
    }

    .headers-list.evidence-list::-webkit-scrollbar-thumb {
      background: rgba(148, 163, 184, 0.3);
      border-radius: 3px;
    }

    .headers-list.evidence-list::-webkit-scrollbar-thumb:hover {
      background: rgba(148, 163, 184, 0.5);
    }

    .headers-list.evidence-list .header-name {
      color: var(--primary);
    }

    .analysis-actions {
      display: flex;
      justify-content: center;
      gap: clamp(0.6rem, 1.2vw, 0.9rem);
      flex-wrap: wrap;
      margin-top: 1rem;
    }

    a.btn {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.65rem 0.9rem;
      border-radius: 10px;
      border: 1px solid var(--border);
      text-decoration: none;
      color: var(--text);
      background: rgba(148, 163, 184, 0.06);
      font-weight: 700;
      transition: transform 80ms ease, background 120ms ease, border-color 120ms ease, opacity 120ms ease;
    }

    a.btn:hover {
      background: rgba(148, 163, 184, 0.10);
      transform: translateY(-1px);
    }

    a.btn:active {
      transform: translateY(0);
    }

    a.btn:focus-visible {
      outline: none;
      box-shadow: 0 0 0 4px var(--ring);
    }

    a.btn.primary {
      background: var(--primary);
      border-color: var(--primary);
      color: var(--primary-ink);
    }

    a.btn.success {
      background: var(--success);
      border-color: var(--success);
      color: var(--success-ink);
    }

    @media (max-width: 520px) {
      .analysis-actions {
        flex-direction: column;
        align-items: stretch;
      }

      .analysis-actions .btn {
        justify-content: center;
        width: 100%;
      }

      .checklabel {
        white-space: normal;
      }
    }

    @media (prefers-reduced-motion: reduce) {

      .analysis-card,
      a.btn {
        transition: none;
      }

      .analysis-card:hover,
      a.btn:hover {
        transform: none;
      }
    }

    .split {
      display: grid;
      grid-template-columns: minmax(0, 1fr) minmax(280px, 360px);
      gap: 1.25rem;
      align-items: start;
    }

    @media (max-width: 980px) {
      .split {
        grid-template-columns: 1fr;
      }
    }

    /* Page metadata card */
    .page-meta {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.75rem;
      margin-bottom: 1rem;
    }

    @media (max-width: 600px) {
      .page-meta {
        grid-template-columns: 1fr;
      }
    }

    .page-meta-item {
      background: linear-gradient(135deg, rgba(148, 163, 184, 0.08), rgba(148, 163, 184, 0.03));
      border: 1px solid rgba(148, 163, 184, 0.18);
      border-radius: 10px;
      padding: 0.65rem 0.85rem;
    }

    .page-meta-label {
      font-size: 0.72rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: var(--muted);
      margin-bottom: 0.25rem;
    }

    .page-meta-value {
      font-size: 0.88rem;
      font-weight: 600;
      color: var(--text);
      line-height: 1.4;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    /* Headers categories */
    .headers-section {
      margin-bottom: 0.85rem;
    }

    .headers-section:last-child {
      margin-bottom: 0;
    }

    .headers-category {
      font-size: 0.72rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: var(--muted);
      padding: 0.5rem 0.65rem 0.35rem;
      background: rgba(148, 163, 184, 0.06);
      border-bottom: 1px solid rgba(148, 163, 184, 0.14);
    }

    .mini-toggle {
      border: 1px solid rgba(148, 163, 184, 0.22);
      border-radius: 12px;
      background: rgba(148, 163, 184, 0.06);
      padding: 0.35rem 0.55rem;
    }

    .mini-toggle summary {
      cursor: pointer;
      user-select: none;
      list-style: none;
      font-size: 0.85rem;
      font-weight: 700;
      color: var(--text);
    }

    .mini-toggle summary::-webkit-details-marker {
      display: none;
    }

    .headers-list {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: rgba(148, 163, 184, 0.03);
      overflow: auto;
      max-height: 320px;
      min-width: 0;
    }

    .header-row {
      display: grid;
      grid-template-columns: minmax(140px, 200px) 1fr;
      gap: 0.6rem;
      padding: 0.45rem 0.65rem;
      border-bottom: 1px solid rgba(148, 163, 184, 0.14);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: 0.82rem;
    }

    .header-row:last-child {
      border-bottom: none;
    }

    .header-name {
      color: var(--primary);
      font-weight: 700;
    }

    .header-value {
      overflow-wrap: anywhere;
      color: var(--text);
    }

    .screenshot {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: linear-gradient(180deg, rgba(148, 163, 184, 0.06), rgba(148, 163, 184, 0.02));
      padding: 0.75rem;
      min-width: 0;
      position: sticky;
      top: 1rem;
    }

    .screenshot-label {
      font-size: 0.72rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: var(--muted);
      margin-bottom: 0.5rem;
      text-align: center;
    }

    .screenshot img {
      width: 100%;
      height: auto;
      border-radius: 10px;
      display: block;
      background: rgba(148, 163, 184, 0.06);
      cursor: zoom-in;
      border: 1px solid rgba(148, 163, 184, 0.18);
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    .screenshot img:hover {
      transform: scale(1.02);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
    }

    .screenshot .placeholder {
      border: 1px dashed rgba(148, 163, 184, 0.4);
      border-radius: 12px;
      padding: 1.5rem 1rem;
      text-align: center;
      color: var(--muted);
      font-weight: 600;
      font-size: 0.85rem;
    }

    /* Network Information improvements */
    .network-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
      align-items: start;
    }

    @media (max-width: 900px) {
      .network-grid {
        grid-template-columns: 1fr;
      }
    }

    .network-card {
      background: linear-gradient(135deg, rgba(148, 163, 184, 0.08), rgba(148, 163, 184, 0.03));
      border: 1px solid rgba(148, 163, 184, 0.18);
      border-radius: 12px;
      padding: 1rem;
    }

    .network-card-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      margin-bottom: 0.75rem;
      padding-bottom: 0.65rem;
      border-bottom: 1px solid rgba(148, 163, 184, 0.14);
    }

    .network-card-title {
      font-size: 0.85rem;
      font-weight: 700;
      color: var(--text);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .network-card-icon {
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.9rem;
    }

    .network-card-badge {
      font-size: 0.72rem;
      font-weight: 700;
      padding: 0.2rem 0.5rem;
      border-radius: 999px;
      background: var(--success-soft);
      color: var(--success);
    }

    .dns-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .dns-item {
      border: 1px solid rgba(148, 163, 184, 0.22);
      border-radius: 8px;
      padding: 0.45rem 0.7rem;
      background: rgba(148, 163, 184, 0.04);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: 0.82rem;
      font-variant-numeric: tabular-nums;
      font-weight: 600;
      color: var(--success);
      white-space: nowrap;
    }

    .whois-grid {
      display: grid;
      gap: 0.6rem;
    }

    .whois-row {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 0.5rem;
      padding: 0.4rem 0;
      border-bottom: 1px solid rgba(148, 163, 184, 0.1);
    }

    .whois-row:last-child {
      border-bottom: none;
      padding-bottom: 0;
    }

    .whois-label {
      font-size: 0.78rem;
      font-weight: 600;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }

    .whois-value {
      font-size: 0.88rem;
      font-weight: 700;
      color: var(--text);
      text-align: right;
    }

    .whois-value.highlight {
      color: var(--success);
    }

    .domain-age {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      font-size: 0.72rem;
      font-weight: 700;
      padding: 0.2rem 0.5rem;
      border-radius: 999px;
      background: var(--primary-soft);
      color: var(--primary);
    }

    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1.25rem;
      z-index: 1000;
    }

    .modal img {
      max-width: min(1100px, 96vw);
      max-height: 86vh;
      border-radius: 14px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(15, 23, 42, 0.95);
    }
  </style>
</head>

<body>
  <!-- Skip to main content link for keyboard/screen reader users -->
  <a href="#main-content" class="skip-link">Skip to main content</a>

  <!-- Toast notification container -->
  <div id="toastContainer" class="toast-container" role="region" aria-label="Notifications" aria-live="polite"></div>

  <div class="app">
    <header class="header">
      <div>
        <h1>URL Security Scanner</h1>
        <p class="sub">Analyze URLs for security threats, phishing indicators, and web vulnerabilities. <a
            href="/docs">API Docs</a></p>
      </div>
      <div class="actions">
        <a class="tab" aria-current="page" href="/">URL scanner</a>
        <a class="tab" href="/file">File scanner</a>
        <button id="clearHistory" type="button">Clear history</button>
      </div>
    </header>

    <main id="main-content">
      <div class="grid">
        <section class="card" aria-labelledby="new-scan-heading">
          <h2 id="new-scan-heading">New scan</h2>
          <div class="field">
            <label for="apiKey">API key <span class="muted">(header: __API_KEY_HEADER__)</span></label>
            <div class="api-key-group">
              <input id="apiKey" class="api-key-input" type="password" autocomplete="off" placeholder="Paste API key" />
              <button id="apiKeyToggle" type="button" class="api-key-toggle" title="Show/hide API key"
                aria-label="Toggle API key visibility"><svg class="eye-icon" viewBox="0 0 24 24">
                  <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" />
                  <circle cx="12" cy="12" r="3" />
                </svg></button>
              <span id="apiKeySaved" class="api-key-saved" style="display: none;"
                title="Saved to local storage">✓</span>
            </div>
            <div class="help">Saved in this browser only (local storage).</div>
          </div>
          <div class="field">
            <label for="url">HTTPS URL to scan <span class="muted"><kbd class="kbd"
                  title="Press Ctrl+Enter or Cmd+Enter to scan">⌘↵</kbd></span></label>
            <div class="url-group">
              <span class="url-scheme" aria-hidden="true">https://</span>
              <input id="url" class="url-input" inputmode="url" autocomplete="off" placeholder="example.com"
                aria-describedby="url-help" />
            </div>
            <div id="url-help" class="help">Only public HTTPS destinations on port 443 are allowed.</div>
          </div>
          <div class="actions">
            <button id="start" class="primary" type="button" aria-describedby="start-hint">Start scan</button>
            <button id="checkCurrent" type="button" disabled>Check job</button>
            <button id="copyJson" type="button" disabled>Copy JSON</button>
          </div>
          <div id="status" class="status" role="status" aria-live="polite" aria-atomic="true"></div>
        </section>

        <section class="card" aria-labelledby="history-heading">
          <div class="card-head">
            <h2 id="history-heading">History</h2>
            <div class="history-controls">
              <input id="historyFilter" class="filter" placeholder="Filter by URL or job id"
                aria-label="Filter history" />
              <select id="historyOrder" class="select" aria-label="Order history">
                <option value="recent" selected>Most recent</option>
                <option value="oldest">Oldest</option>
              </select>
            </div>
          </div>
          <div class="table-wrap" role="region" aria-label="Scan history">
            <table>
              <thead>
                <tr>
                  <th class="nowrap" scope="col">When</th>
                  <th scope="col">URL</th>
                  <th class="nowrap" scope="col">Job</th>
                  <th class="nowrap">Status</th>
                  <th class="nowrap">Actions</th>
                </tr>
              </thead>
              <tbody id="historyBody"></tbody>
            </table>
          </div>
          <div class="history-pager" aria-label="History pagination">
            <button id="historyPrev" type="button">Prev</button>
            <span id="historyPageInfo" class="muted small"></span>
            <button id="historyNext" type="button">Next</button>
          </div>
          <p class="muted small">History is tied to your API key and stored server-side.</p>
        </section>

        <section class="card full">
          <div class="card-head">
            <h2>Response</h2>
            <div class="actions">
              <button id="copyJson2" type="button" disabled>Copy JSON</button>
            </div>
          </div>
          <div class="tabs" role="tablist" aria-label="Response view">
            <button id="tabSummary" class="tab" role="tab" aria-selected="true" aria-controls="panelSummary"
              type="button">Summary</button>
            <button id="tabRaw" class="tab" role="tab" aria-selected="false" aria-controls="panelRaw" type="button">Raw
              JSON</button>
          </div>
          <div id="panelSummary" class="panel" role="tabpanel" aria-labelledby="tabSummary">
            <div id="summaryOut" class="summary-grid"></div>
          </div>
          <div id="panelRaw" class="panel hidden" role="tabpanel" aria-labelledby="tabRaw">
            <pre id="out">{}</pre>
          </div>
        </section>
      </div>
    </main>
  </div>

  <script>
    (function () {
      const API_KEY_HEADER = __API_KEY_HEADER_JSON__;
      const MAX_POLL_SECONDS = __MAX_DASHBOARD_POLL_SECONDS__;
      const WEBPUBSUB_ENABLED = __WEBPUBSUB_ENABLED__;
      const WEBPUBSUB_SUBPROTOCOL = 'json.webpubsub.azure.v1';

      const LS = {
        apiKey: 'acaScanner.apiKey',
        history: 'acaScanner.scanHistory.v1',
        legacyApiKey: 'apiKey',
      };

      const apiKeyEl = document.getElementById('apiKey');
      const apiKeyToggleEl = document.getElementById('apiKeyToggle');
      const apiKeySavedEl = document.getElementById('apiKeySaved');
      const urlEl = document.getElementById('url');
      const outEl = document.getElementById('out');
      const summaryOutEl = document.getElementById('summaryOut');
      const statusEl = document.getElementById('status');
      const startEl = document.getElementById('start');
      const historyBodyEl = document.getElementById('historyBody');
      const historyFilterEl = document.getElementById('historyFilter');
      const historyOrderEl = document.getElementById('historyOrder');
      const historyPrevEl = document.getElementById('historyPrev');
      const historyNextEl = document.getElementById('historyNext');
      const historyPageInfoEl = document.getElementById('historyPageInfo');
      const clearHistoryEl = document.getElementById('clearHistory');
      const checkCurrentEl = document.getElementById('checkCurrent');
      const copyJsonEl = document.getElementById('copyJson');
      const copyJson2El = document.getElementById('copyJson2');
      const tabSummaryEl = document.getElementById('tabSummary');
      const tabRawEl = document.getElementById('tabRaw');
      const panelSummaryEl = document.getElementById('panelSummary');
      const panelRawEl = document.getElementById('panelRaw');
      const toastContainerEl = document.getElementById('toastContainer');

      // ===========================================
      // Toast Notification System
      // ===========================================
      const toastQueue = [];
      let toastCounter = 0;

      function showToast(message, type = 'info', duration = 4000) {
        const id = ++toastCounter;
        const icons = { success: '✓', error: '✕', warn: '!', info: 'i' };

        const toast = el('div', { class: 'toast toast-' + type, 'data-toast-id': String(id) },
          el('span', { class: 'toast-icon', 'aria-hidden': 'true', text: icons[type] || icons.info }),
          el('span', { class: 'toast-message', text: message }),
          el('button', { class: 'toast-close', 'aria-label': 'Dismiss', type: 'button', text: '✕' })
        );

        const closeBtn = toast.querySelector('.toast-close');
        closeBtn.addEventListener('click', () => dismissToast(toast));

        toastContainerEl.appendChild(toast);
        toastQueue.push({ id, toast, timer: null });

        if (duration > 0) {
          const entry = toastQueue.find(t => t.id === id);
          if (entry) {
            entry.timer = setTimeout(() => dismissToast(toast), duration);
          }
        }

        // Limit max visible toasts
        while (toastQueue.length > 5) {
          const oldest = toastQueue.shift();
          if (oldest && oldest.toast.isConnected) {
            if (oldest.timer) clearTimeout(oldest.timer);
            oldest.toast.remove();
          }
        }

        return id;
      }

      function dismissToast(toast) {
        if (!toast || !toast.isConnected) return;
        toast.classList.add('toast-out');
        setTimeout(() => {
          if (toast.isConnected) toast.remove();
          const idx = toastQueue.findIndex(t => t.toast === toast);
          if (idx >= 0) {
            if (toastQueue[idx].timer) clearTimeout(toastQueue[idx].timer);
            toastQueue.splice(idx, 1);
          }
        }, 200);
      }

      // ===========================================
      // Button Loading State Helpers
      // ===========================================
      function setButtonLoading(btn, loading) {
        if (!btn) return;
        if (loading) {
          btn.classList.add('loading');
          btn.disabled = true;
        } else {
          btn.classList.remove('loading');
          // Don't auto-enable - let the caller decide
        }
      }

      let history = [];
      let currentJobId = null;
      let currentRunId = null;
      let isSubmitting = false;
      const activePolls = new Map(); // job_id -> Promise
      let activeTab = 'summary'; // 'summary' | 'raw'
      let pollToken = 0;
      let pubsubSocket = null;
      let pubsubReconnectTimer = null;
      let pubsubReconnectMs = 0;
      let pubsubDesired = false;
      let liveConnectTimer = null;
      let liveFallbackPollTimer = null;
      const intentionalSocketCloses = new WeakSet();
      const terminalToastByJob = new Map(); // job_id -> terminal status
      const lastLiveStatusByRun = new Map(); // run_id -> status
      const viewFetchInFlightJobs = new Set(); // job_id
      const viewLastFetchAt = new Map(); // job_id -> epoch ms
      const VIEW_FETCH_THROTTLE_MS = 1200;

      let lastSummary = null; // most recent response for summary view
      let lastFull = null; // most recent response for full view (raw JSON)
      let lastSummaryJobId = null;
      let lastFullJobId = null;

      const screenshotCache = new Map(); // screenshotUrl -> objectUrl
      const screenshotPending = new Map(); // screenshotUrl -> Promise<objectUrl>

      const dtf = new Intl.DateTimeFormat(undefined, { dateStyle: 'medium', timeStyle: 'short' });
      const HTTPS_PREFIX = 'https://';

      const HISTORY_FETCH_LIMIT = 500;
      const HISTORY_ROWS_PER_PAGE = 5;
      const HISTORY_PAGE_SIZE = HISTORY_ROWS_PER_PAGE;

      let historyPage = 1;
      let historyLoading = false;
      let historyLoadError = null;
      let historyLastLoadedAt = null;
      let historyRefreshTimer = null;

      function normalizeUrlInput(raw) {
        const v = String(raw || '').trim();
        if (!v) return '';
        return v.replace(/^https:\/\//i, '');
      }

      function toHttpsUrl(raw) {
        const v = String(raw || '').trim();
        if (!v) return '';
        if (/^https:\/\//i.test(v)) return v;
        if (/^http:\/\//i.test(v)) throw new Error('Only HTTPS URLs are allowed');
        return HTTPS_PREFIX + v.replace(/^\/+/, '');
      }

      function readJson(key, fallback) {
        try {
          const raw = localStorage.getItem(key);
          if (!raw) return fallback;
          return JSON.parse(raw);
        } catch (_) {
          return fallback;
        }
      }

      function writeJson(key, value) {
        localStorage.setItem(key, JSON.stringify(value));
      }

      function upsertHistory(entry) {
        const idx = history.findIndex(x => x && x.job_id === entry.job_id);
        if (idx >= 0) history[idx] = Object.assign({}, history[idx], entry);
        else history.unshift(entry);
        renderHistory();
      }

      function patchHistory(jobId, patch) {
        const idx = history.findIndex(x => x && x.job_id === jobId);
        if (idx < 0) return;
        history[idx] = Object.assign({}, history[idx], patch);
        renderHistory();
      }

      function resetHistoryPaging() {
        historyPage = 1;
      }

      function scheduleHistoryRefresh(ms) {
        if (historyRefreshTimer) clearTimeout(historyRefreshTimer);
        historyRefreshTimer = setTimeout(() => {
          resetHistoryPaging();
          refreshHistoryFromServer({ silent: true });
        }, Math.max(0, Number(ms || 0)) || 450);
      }

      async function refreshHistoryFromServer(opts) {
        const silent = opts && opts.silent;
        historyLoadError = null;

        const key = apiKeyEl.value.trim();
        if (!key) {
          history = [];
          historyLastLoadedAt = null;
          renderHistory();
          return;
        }

        historyLoading = true;
        renderHistory();
        try {
          const res = await api('/jobs?limit=' + HISTORY_FETCH_LIMIT + '&type=url', 'GET');
          const jobs = res && res.jobs;
          if (!Array.isArray(jobs)) {
            throw Object.assign(new Error('Invalid /jobs response'), { data: res });
          }
          history = jobs;
          historyLastLoadedAt = new Date().toISOString();
          if (!silent) setStatus('ok', 'History refreshed');
        } catch (e) {
          const info = formatApiError(e);
          history = [];
          historyLoadError = info.message || 'Failed to load history';
          if (!silent) setStatus('warn', historyLoadError);
        } finally {
          historyLoading = false;
          renderHistory();
        }
      }

      async function clearHistoryServer() {
        const key = apiKeyEl.value.trim();
        if (!key) {
          history = [];
          historyLastLoadedAt = null;
          renderHistory();
          return;
        }
        try {
          await api('/jobs?type=url', 'DELETE');
          setStatus('ok', 'History cleared');
          showToast('History cleared', 'success', 2500);
        } catch (e) {
          const info = formatApiError(e);
          const msg = info.message || 'Failed to clear history';
          setStatus('warn', msg);
          showToast(msg, 'error', 6000);
        } finally {
          resetHistoryPaging();
          await refreshHistoryFromServer({ silent: true });
        }
      }

      function clearScreenshotCache() {
        for (const objectUrl of screenshotCache.values()) {
          try { URL.revokeObjectURL(objectUrl); } catch (_) { }
        }
        screenshotCache.clear();
        screenshotPending.clear();
      }

      function el(tag, attrs) {
        const node = document.createElement(tag);
        if (attrs) {
          for (const [k, v] of Object.entries(attrs)) {
            if (k === 'class') node.className = v;
            else if (k === 'text') node.textContent = v;
            else if (k === 'title') node.title = v;
            else if (k === 'href') node.href = v;
            else if (k === 'target') node.target = v;
            else if (k === 'rel') node.rel = v;
            else node.setAttribute(k, v);
          }
        }
        for (let i = 2; i < arguments.length; i++) {
          const child = arguments[i];
          if (child == null) continue;
          if (typeof child === 'string') node.appendChild(document.createTextNode(child));
          else node.appendChild(child);
        }
        return node;
      }

      function makeBadge(kind, label) {
        const cls = kind ? ('badge ' + kind) : 'badge';
        return el('span', { class: cls, text: label });
      }

      function setStatus(kind, text) {
        statusEl.textContent = '';
        if (!text) return;
        const label = kind === 'ok' ? 'OK' : (kind === 'bad' ? 'ERROR' : (kind === 'warn' ? 'WARN' : 'INFO'));
        statusEl.appendChild(makeBadge(kind || 'info', label));
        statusEl.appendChild(document.createTextNode(' ' + text));
      }

      function setButtonsEnabled(hasJson) {
        copyJsonEl.disabled = !hasJson;
        copyJson2El.disabled = !hasJson;
        checkCurrentEl.disabled = !currentJobId;
      }

      function formatBytes(n) {
        const v = Number(n);
        if (!Number.isFinite(v)) return '';
        if (v < 1024) return v + ' B';
        const kb = v / 1024;
        if (kb < 1024) return kb.toFixed(1) + ' KB';
        const mb = kb / 1024;
        return mb.toFixed(2) + ' MB';
      }

      function formatMs(n) {
        const v = Number(n);
        if (!Number.isFinite(v)) return '';
        if (v < 1000) return v + ' ms';
        return (v / 1000).toFixed(2) + ' s';
      }

      function pick(obj, key) {
        if (!obj || typeof obj !== 'object') return null;
        return obj[key];
      }

      function badgeValue(kind, text) {
        const label = String(text || '');
        return makeBadge(kind || 'info', label);
      }

      function renderSummary(resp) {
        summaryOutEl.textContent = '';
        const data = resp || {};
        const s = (data && data.summary && typeof data.summary === 'object') ? data.summary : {};

        const blocks = [];

        function makeCopyButton(text, label) {
          const hint = label || 'Copy';
          const btn = el('button', { type: 'button', class: 'icon-btn', title: hint, 'aria-label': hint }, 'Copy');
          btn.addEventListener('click', () => copyText(text));
          return btn;
        }

        function copyableValue(valueNode, text, label) {
          const v = String(text || '');
          if (!v) return valueNode;
          return el('span', { class: 'value-row' }, valueNode, makeCopyButton(v, label));
        }

        function codeValue(value, opts) {
          const text = value == null ? '' : String(value);
          const node = el('code', { class: 'value-code', text: text });
          if (opts && opts.copy) return copyableValue(node, text, opts.copyLabel);
          return node;
        }

        // Format timestamp to readable date with time and timezone
        function formatTimestamp(isoStr) {
          try {
            const d = new Date(isoStr);
            if (isNaN(d.getTime())) return String(isoStr);

            const options = {
              year: 'numeric',
              month: 'short',
              day: 'numeric',
              hour: '2-digit',
              minute: '2-digit',
              second: '2-digit',
              timeZoneName: 'short'
            };
            return d.toLocaleString('en-US', options);
          } catch (_) {
            return String(isoStr);
          }
        }

        function timestampValue(isoStr) {
          if (!isoStr) return '';
          const formatted = formatTimestamp(isoStr);
          return el('span', { class: 'timestamp-value', title: String(isoStr), text: formatted });
        }

        // HTTP status code with color coding
        function httpStatusValue(code) {
          const c = Number(code);
          let kind = 'info';
          if (c >= 200 && c < 300) kind = 'ok';
          else if (c >= 300 && c < 400) kind = 'warn';
          else if (c >= 400) kind = 'bad';

          const node = el('code', { class: 'value-code status-' + kind, text: String(code) });
          return node;
        }

        function linkValue(url, opts) {
          const href = String(url || '');
          const node = el('a', { class: 'value-link', href: href, target: '_blank', rel: 'noreferrer', text: href });
          if (opts && opts.copy) return copyableValue(node, href, opts.copyLabel);
          return node;
        }

        function block(title, rows, opts) {
          const kvClass = (opts && opts.kvClass) ? String(opts.kvClass) : '';
          const dl = el('dl', { class: 'kv' + (kvClass ? (' ' + kvClass) : '') });
          for (const [k, v] of rows) {
            if (v == null || v === '') continue;
            const row = el('div', { class: 'kv-row' });
            row.appendChild(el('dt', { text: k }));
            const dd = el('dd');
            if (v && typeof v === 'object' && v.nodeType === 1) dd.appendChild(v);
            else dd.textContent = String(v);
            row.appendChild(dd);
            dl.appendChild(row);
          }
          const header = el('h3', null, el('span', { class: 'summary-title', text: title }));
          const metaNodes = (opts && Array.isArray(opts.meta)) ? opts.meta.filter(Boolean) : [];
          if (metaNodes.length) header.appendChild(el('span', { class: 'summary-meta' }, ...metaNodes));
          const tone = opts && opts.tone ? String(opts.tone) : '';
          const spanAll = Boolean(opts && opts.spanAll);
          const cls = 'summary-block'
            + (tone ? (' tone-' + tone) : '')
            + (spanAll ? ' span-all' : '');
          blocks.push(el('div', { class: cls }, header, dl));
        }

        const SECURITY_FIELD_HELP = {
          'Protocol': 'The connection scheme for the final URL. HTTPS encrypts data in transit.',
          'Mixed Content': 'An HTTPS page that loads any HTTP (non-encrypted) resources. This can weaken security.',
          'Content Security Policy': 'Rules that tell the browser which scripts/resources are allowed. Helps block injected scripts.',
          'X Frame Options': 'Controls whether the page can be shown inside an iframe. Helps prevent clickjacking.',
          'Xss Protection': 'Older XSS filter header. Modern browsers may ignore it, but it can still help in some cases.',
          'Login Forms': 'Number of forms that look like logins (usually forms with password fields).',
          'Password Fields': 'Number of password inputs found in the page HTML.',
          'Csrf Protection': "Looks for CSRF tokens/fields. Without them, a malicious site may trigger actions while you're logged in.",
          'Suspicious Scripts': 'Scripts that match suspicious patterns (obfuscation, risky APIs). Higher counts can be a red flag.',
          'External Scripts': "Scripts loaded from outside the site's domain. Third-party scripts increase risk.",
          'Suspicious Api Calls': 'JavaScript making network calls to external or unusual endpoints (fetch/XHR/WebSocket).',
          'Insecure Cookies': 'Cookies missing Secure (and similar risky settings). This is especially risky for session/auth cookies.',
          'Open Redirects': 'Links/parameters that may redirect to another site. Often abused in phishing.',
          'Inner Html Usage': 'Use of `innerHTML` to insert HTML. Unsafe with untrusted data and can lead to XSS.',
          'Eval Usage': 'Use of `eval()` to run dynamic code. Risky and often used by obfuscated scripts.',
          'Tracking Scripts': 'Known tracking/analytics resources detected. Can impact privacy.',
          'Fingerprinting': 'Scripts that try to uniquely identify a browser/device (fingerprinting).',
        };

        const SECURITY_FIELD_HOW = {
          'Protocol': 'Derived from the final URL scheme after redirects.',
          'Mixed Content': 'We parse the HTML and list resources that load over http://.',
          'Content Security Policy': 'We check response header names for CSP/CSP-Report-Only.',
          'X Frame Options': 'We check response header names for X-Frame-Options.',
          'Xss Protection': 'We check response header names for X-XSS-Protection.',
          'Login Forms': 'We count <form> elements that contain at least one password input.',
          'Password Fields': 'We count <input type="password"> elements in the HTML.',
          'Csrf Protection': 'We look for csrf/xsrf indicators in hidden inputs and meta tags.',
          'Suspicious Scripts': 'We flag scripts loaded from IP addresses and inline scripts matching heuristic indicators.',
          'External Scripts': "We count scripts whose registrable domain differs from the page's domain.",
          'Suspicious Api Calls': 'We scan inline scripts for absolute URLs used with fetch/XHR/WebSocket/etc (cross-domain or IP).',
          'Insecure Cookies': 'We parse Set-Cookie headers and flag cookies with risky/missing attributes.',
          'Open Redirects': 'We look for common redirect params (next, redirect, return_url, etc) that point to external URLs.',
          'Inner Html Usage': 'We scan inline JS for innerHTML/outerHTML usage (YARA Web_InnerHTML_Usage_INFO).',
          'Eval Usage': 'We scan inline JS for eval()/new Function() usage (YARA Web_Eval_Usage_INFO).',
          'Tracking Scripts': 'We apply tracking filter rules to resource URLs and scan inline scripts for analytics calls.',
          'Fingerprinting': 'We scan script URLs and inline scripts for fingerprinting libraries/APIs (YARA Web_Fingerprinting_INFO).',
        };

        function evidenceBox(title, rows) {
          const pairs = Array.isArray(rows) ? rows.filter(Boolean) : [];
          if (!pairs.length) return null;

          const list = el('div', { class: 'headers-list evidence-list' });
          let count = 0;
          for (const pair of pairs) {
            if (!Array.isArray(pair) || pair.length < 2) continue;
            const k = String(pair[0] == null ? '' : pair[0]);
            const v = pair[1];
            if (!k) continue;
            const valueNode = (v && typeof v === 'object' && v.nodeType === 1)
              ? el('div', { class: 'header-value' }, v)
              : el('div', { class: 'header-value', text: String(v == null ? '' : v) });
            list.appendChild(el('div', { class: 'header-row' },
              el('div', { class: 'header-name', text: k }),
              valueNode
            ));
            count++;
          }

          if (!count) return null;
          const details = el('details', { class: 'mini-toggle' });
          details.appendChild(el('summary', { text: String(title || 'Details') }));
          details.appendChild(list);
          return details;
        }

        function checkLine(label, value, kind, opts) {
          const k = kind || 'info';
          const labelText = String(label || '');
          const helpText = SECURITY_FIELD_HELP[labelText] || '';
          const howText = SECURITY_FIELD_HOW[labelText] || '';
          const reasonText = (opts && opts.reason) ? String(opts.reason) : '';
          const extra = (opts && opts.extra && typeof opts.extra === 'object') ? opts.extra : null;
          const details = el('details', { class: 'checkline ' + k });
          // Add data attribute to track status for summary counting
          details.setAttribute('data-check-status', k);
          const summary = el('summary', null,
            el('span', { class: 'checkleft' },
              el('span', { class: 'checkdot' }),
              el('span', { class: 'checklabel', text: labelText }),
              el('span', { class: 'checkhint', title: 'Click to expand', text: '?' })
            ),
            el('span', { class: 'checkvalue', text: String(value || '') })
          );
          details.appendChild(summary);
          if (reasonText) details.appendChild(el('div', { class: 'checkhelp', text: 'Reason: ' + reasonText }));
          if (helpText) details.appendChild(el('div', { class: 'checkhelp', text: helpText }));
          if (howText) details.appendChild(el('div', { class: 'checkhelp', text: 'How: ' + howText }));
          if (extra) details.appendChild(extra);
          return details;
        }

        function securitySummaryBar(cards) {
          // Count all checklines by status
          let okCount = 0, warnCount = 0, badCount = 0;
          const allChecks = cards.querySelectorAll('[data-check-status]');
          allChecks.forEach(check => {
            const status = check.getAttribute('data-check-status');
            if (status === 'ok') okCount++;
            else if (status === 'warn') warnCount++;
            else if (status === 'bad') badCount++;
          });

          return el('div', { class: 'security-summary' },
            el('div', { class: 'security-stat stat-ok' },
              el('span', { class: 'security-stat-icon' }),
              el('span', { text: String(okCount) }),
              el('span', { class: 'security-stat-label', text: 'Passed' })
            ),
            el('div', { class: 'security-stat stat-warn' },
              el('span', { class: 'security-stat-icon' }),
              el('span', { text: String(warnCount) }),
              el('span', { class: 'security-stat-label', text: 'Warnings' })
            ),
            el('div', { class: 'security-stat stat-bad' },
              el('span', { class: 'security-stat-icon' }),
              el('span', { text: String(badCount) }),
              el('span', { class: 'security-stat-label', text: 'Issues' })
            )
          );
        }

        function cardGroupLabel(text) {
          return el('div', { class: 'card-group-label', text: text });
        }

        function analysisCard(title, lines, opts) {
          const nodes = Array.isArray(lines) ? lines.filter(Boolean) : [];
          const body = el('div', { class: 'checklist' }, ...nodes);
          const tone = (opts && opts.tone) ? String(opts.tone) : '';
          const cls = 'analysis-card' + (tone ? (' tone-' + tone) : '');
          return el('div', { class: cls }, el('h4', { text: String(title || '') }), body, (opts && opts.extra) ? opts.extra : null);
        }

        function section(title, body, opts) {
          const meta = (opts && opts.meta) ? opts.meta : null;
          const head = el('div', { class: 'section-head' },
            el('h3', { class: 'section-title', text: String(title || '') }),
            meta
          );
          const node = el('div', { class: 'section' }, head, body);
          blocks.push(node);
        }

        function openImageModal(src) {
          const url = String(src || '');
          if (!url) return;
          const overlay = el('div', { class: 'modal', role: 'dialog', 'aria-label': 'Screenshot' });
          const img = el('img', { src: url, alt: 'Page screenshot' });
          overlay.appendChild(img);
          overlay.addEventListener('click', () => overlay.remove());
          document.body.appendChild(overlay);
        }

        function hostnameFromUrl(url) {
          try { return new URL(String(url || '')).hostname || ''; } catch (_) { return ''; }
        }

        function registrableDomain(host) {
          const h = String(host || '').trim().toLowerCase().replace(/\.+$/, '');
          const labels = h.split('.').filter(Boolean);
          if (labels.length < 2) return h;

          const publicSuffix2 = new Set([
            'co.uk', 'org.uk', 'gov.uk', 'ac.uk',
            'com.au', 'net.au', 'org.au',
            'co.jp', 'co.in',
            'com.br', 'com.mx', 'co.nz', 'com.sg',
          ]);
          const last2 = labels.slice(-2).join('.');
          if (labels.length >= 3 && publicSuffix2.has(last2)) return labels.slice(-3).join('.');
          return last2;
        }

        function vtUrlId(url) {
          const u = String(url || '').trim();
          if (!u) return '';

          function toBase64(bytes) {
            let bin = '';
            for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);
            return btoa(bin);
          }

          try {
            const bytes = new TextEncoder().encode(u);
            return toBase64(bytes).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');
          } catch (_) {
            try {
              // Fallback for older browsers.
              const b64 = btoa(unescape(encodeURIComponent(u)));
              return b64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');
            } catch (_) {
              return '';
            }
          }
        }

        function urlscanQuery(url) {
          const u = String(url || '').trim();
          if (!u) return '';
          const escaped = u.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
          return 'page.url:"' + escaped + '"';
        }

        function externalScanActions(targetUrl) {
          const url = String(targetUrl || '').trim();
          if (!url) return null;

          const urlscanQ = urlscanQuery(url);
          const urlscanDomain = registrableDomain(hostnameFromUrl(url));
          const urlscanHref = urlscanDomain
            ? ('https://urlscan.io/domain/' + encodeURIComponent(urlscanDomain))
            : (urlscanQ ? ('https://urlscan.io/search/#' + encodeURIComponent(urlscanQ)) : 'https://urlscan.io/');
          const vtId = vtUrlId(url);
          const vtHost = hostnameFromUrl(url);
          const vtHref = vtId
            ? ('https://www.virustotal.com/gui/url/' + vtId)
            : (vtHost ? ('https://www.virustotal.com/gui/domain/' + encodeURIComponent(vtHost)) : 'https://www.virustotal.com/');

          return el('div', { class: 'analysis-actions' },
            el('a', { class: 'btn primary', href: urlscanHref, target: '_blank', rel: 'noreferrer', text: 'Check on URLScan.io' }),
            el('a', { class: 'btn success', href: vtHref, target: '_blank', rel: 'noreferrer', text: 'Check on VirusTotal' }),
          );
        }

        const status = String(data.status || 'unknown');
        const isTerminal = status === 'completed' || status === 'error' || status === 'blocked';
        const dl = (pick(s, 'download') && typeof pick(s, 'download') === 'object') ? pick(s, 'download') : {};
        const web = (pick(s, 'web') && typeof pick(s, 'web') === 'object') ? pick(s, 'web') : {};
        const sec = (web && typeof web.security_analysis === 'object') ? web.security_analysis : {};
        const pageInfo = (web && typeof web.page_information === 'object') ? web.page_information : {};
        const netInfo = (web && typeof web.network_information === 'object') ? web.network_information : {};

        const baseUrl = (dl && dl.final_url) ? String(dl.final_url) : (s.url ? String(s.url) : '');
        const requestedUrl = (dl && dl.requested_url) ? String(dl.requested_url) : (s.url ? String(s.url) : '');
        const finalUrl = baseUrl || requestedUrl;

        const statusBadge = badgeValue(statusKind(status), status);
        block('Scan', [
          ['Status', statusBadge],
          ['Job id', data.job_id ? codeValue(String(data.job_id), { copy: true, copyLabel: 'Copy job id' }) : ''],
          ['Submitted', data.submitted_at ? timestampValue(data.submitted_at) : ''],
          ['Scanned', data.scanned_at ? timestampValue(data.scanned_at) : ''],
          ['Duration', data.duration_ms != null ? formatMs(data.duration_ms) : ''],
          ['Error', data.error || ''],
        ].filter(Boolean), { tone: statusKind(status) });

        block('Destination', [
          ['Destination', finalUrl ? linkValue(finalUrl, { copy: true, copyLabel: 'Copy destination url' }) : ''],
          (requestedUrl && finalUrl && requestedUrl !== finalUrl)
            ? ['Original URL', linkValue(requestedUrl, { copy: true, copyLabel: 'Copy original url' })]
            : null,
          ['HTTP status', (dl && dl.status_code != null) ? httpStatusValue(dl.status_code) : ''],
          ['Content type', (dl && dl.content_type) ? codeValue(String(dl.content_type)) : ''],
          ['Redirects', (dl && dl.redirect_count != null) ? codeValue(String(dl.redirect_count)) : ''],
        ].filter(Boolean), { tone: 'info' });

        // --- External Scanners (for blocked results) ---
        if (status === 'blocked') {
          const actions = externalScanActions(finalUrl);
          if (actions) {
            section('External Scanners', actions);
          }
        }

        // --- Security Analysis (cards) ---
        if (isTerminal && sec && Object.keys(sec).length) {
          const conn = (sec.connection_security && typeof sec.connection_security === 'object') ? sec.connection_security : {};
          const mixed = (conn.mixed_content && typeof conn.mixed_content === 'object') ? conn.mixed_content : {};
          const mixedDetected = mixed.detected === true;
          const mixedCount = Number(mixed.count || 0);
          const mixedExamples = Array.isArray(mixed.examples) ? mixed.examples : [];
          const proto = conn.protocol ? String(conn.protocol) : 'HTTPS';

          const headers = (sec.security_headers && typeof sec.security_headers === 'object') ? sec.security_headers : {};
          const cspPresent = headers.content_security_policy && headers.content_security_policy.present === true;
          const xfoPresent = headers.x_frame_options && headers.x_frame_options.present === true;
          const xssPresent = headers.x_xss_protection && headers.x_xss_protection.present === true;

          const forms = (sec.forms_and_input && typeof sec.forms_and_input === 'object') ? sec.forms_and_input : {};
          const loginForms = Number(forms.login_forms || 0);
          const passwordFields = Number(forms.password_fields || 0);
          const csrfOk = forms.csrf_protection === true;

          const scripts = (sec.suspicious_scripts && typeof sec.suspicious_scripts === 'object') ? sec.suspicious_scripts : {};
          const suspiciousScripts = Number(scripts.suspicious_scripts || 0);
          const externalScripts = Number(scripts.external_scripts || 0);
          const apiSuspicious = scripts.suspicious_api_calls === true;
          const externalScriptExamples = Array.isArray(scripts.external_script_examples) ? scripts.external_script_examples : [];
          const suspiciousIpScriptExamples = Array.isArray(scripts.suspicious_ip_script_examples) ? scripts.suspicious_ip_script_examples : [];
          const suspiciousInlineIndicators = Array.isArray(scripts.suspicious_inline_indicators) ? scripts.suspicious_inline_indicators : [];
          const suspiciousApiCallExamples = Array.isArray(scripts.suspicious_api_call_examples) ? scripts.suspicious_api_call_examples : [];

          const cookies = (sec.cookies && typeof sec.cookies === 'object') ? sec.cookies : {};
          const insecureCookies = Number(cookies.insecure_cookies || 0);
          const cookieDetails = Array.isArray(cookies.details) ? cookies.details : [];
          let cookieExtra = null;
          if (cookieDetails.length) {
            const details = el('details', { class: 'mini-toggle' });
            const summary = el('summary', { text: 'Details' });
            details.appendChild(summary);
            const list = el('div', { class: 'headers-list' });
            for (const c of cookieDetails.slice(0, 20)) {
              if (!c || typeof c !== 'object') continue;
              const name = c.name ? String(c.name) : '';
              const issues = Array.isArray(c.issues) ? c.issues.map(x => String(x)).filter(Boolean) : [];
              if (!name) continue;
              list.appendChild(el('div', { class: 'header-row' },
                el('div', { class: 'header-name', text: name }),
                el('div', { class: 'header-value', text: issues.length ? issues.join(' • ') : '' })
              ));
            }
            details.appendChild(list);
            cookieExtra = details;
          }

          const vulns = (sec.detectable_vulnerabilities && typeof sec.detectable_vulnerabilities === 'object') ? sec.detectable_vulnerabilities : {};
          const openRedirects = vulns.open_redirects === true;
          const innerHtml = vulns.inner_html_usage === true;
          const evalUsage = vulns.eval_usage === true;
          const innerHtmlIndicators = Array.isArray(vulns.inner_html_indicators) ? vulns.inner_html_indicators : [];
          const innerHtmlOccurrences = Number(vulns.inner_html_occurrences || 0);
          const evalIndicators = Array.isArray(vulns.eval_indicators) ? vulns.eval_indicators : [];
          const evalOccurrences = Number(vulns.eval_occurrences || 0);
          const openRedirectExamples = Array.isArray(vulns.open_redirect_examples) ? vulns.open_redirect_examples : [];
          let openRedirectExtra = null;
          if (openRedirectExamples.length) {
            const details = el('details', { class: 'mini-toggle' });
            const summary = el('summary', { text: 'Examples' });
            details.appendChild(summary);
            const list = el('div', { class: 'headers-list' });
            for (const ex of openRedirectExamples.slice(0, 10)) {
              const u = String(ex || '');
              if (!u) continue;
              list.appendChild(el('div', { class: 'header-row' },
                el('div', { class: 'header-name', text: 'url' }),
                el('div', { class: 'header-value', text: u })
              ));
            }
            details.appendChild(list);
            openRedirectExtra = details;
          }

          const tracking = (sec.tracking_features && typeof sec.tracking_features === 'object') ? sec.tracking_features : {};
          const trackingScripts = tracking.tracking_scripts === true;
          const fingerprinting = tracking.fingerprinting === true;
          const trackingResourceExamples = Array.isArray(tracking.tracking_resource_examples) ? tracking.tracking_resource_examples : [];
          const trackingInlineIndicators = Array.isArray(tracking.tracking_inline_indicators) ? tracking.tracking_inline_indicators : [];
          const fingerprintingIndicators = Array.isArray(tracking.fingerprinting_indicators) ? tracking.fingerprinting_indicators : [];

          // Build cards with logical grouping
          const cards = el('div', { class: 'analysis-grid' },
            // --- Connection & Headers Group ---
            cardGroupLabel('Connection & Headers'),
            analysisCard('Connection Security', [
              checkLine('Protocol', proto, (String(proto || '').toLowerCase() === 'https') ? 'ok' : 'warn',
                (String(proto || '').toLowerCase() === 'https') ? null : { reason: 'Final URL is not HTTPS.' }),
              checkLine('Mixed Content', mixedDetected ? 'Detected' : 'Not detected', mixedDetected ? 'bad' : 'ok',
                mixedDetected ? {
                  reason: (mixedCount ? (mixedCount + ' http:// resource(s) found.') : 'http:// resources found.'),
                  extra: evidenceBox('Examples', mixedExamples.slice(0, 10).map((u, idx) => {
                    const url = String(u || '');
                    if (!url) return null;
                    const link = el('a', { href: url, target: '_blank', rel: 'noreferrer', text: url });
                    return [String(idx + 1), link];
                  }))
                } : null),
            ], { tone: mixedDetected ? 'bad' : 'ok' }),
            analysisCard('Security Headers', [
              checkLine('Content Security Policy', cspPresent ? 'Present' : 'Missing', cspPresent ? 'ok' : 'bad',
                cspPresent ? null : { reason: 'CSP header not present in the response.' }),
              checkLine('X Frame Options', xfoPresent ? 'Present' : 'Missing', xfoPresent ? 'ok' : 'warn',
                xfoPresent ? null : { reason: 'X-Frame-Options header not present in the response.' }),
              checkLine('Xss Protection', xssPresent ? 'Present' : 'Missing', xssPresent ? 'ok' : 'warn',
                xssPresent ? null : { reason: 'X-XSS-Protection header not present in the response.' }),
            ], { tone: cspPresent ? 'ok' : 'warn' }),
            analysisCard('Cookies', [
              checkLine('Insecure Cookies', String(insecureCookies), insecureCookies > 0 ? 'bad' : 'ok',
                insecureCookies > 0 ? { reason: 'Cookie attributes are missing or risky (see details).', extra: cookieExtra } : null),
            ], { tone: insecureCookies > 0 ? 'warn' : 'ok' }),
            analysisCard('Forms and Input', [
              checkLine('Login Forms', String(loginForms), loginForms > 0 ? 'warn' : 'ok',
                loginForms > 0 ? { reason: 'Found form(s) containing password inputs.' } : null),
              checkLine('Password Fields', String(passwordFields), passwordFields > 0 ? 'warn' : 'ok',
                passwordFields > 0 ? { reason: 'Found password input(s) in the HTML.' } : null),
              checkLine('Csrf Protection', csrfOk ? 'Yes' : 'No', (loginForms > 0 && !csrfOk) ? 'warn' : (csrfOk ? 'ok' : 'info'),
                (loginForms > 0 && !csrfOk) ? { reason: 'Login form detected, but no CSRF token indicator found.' } : null),
            ], { tone: (loginForms > 0 && !csrfOk) ? 'warn' : 'info' }),

            // --- Content Analysis Group ---
            cardGroupLabel('Content Analysis'),
            analysisCard('Suspicious Scripts', [
              checkLine('Suspicious Scripts', String(suspiciousScripts), suspiciousScripts > 0 ? 'warn' : 'ok',
                suspiciousScripts > 0 ? {
                  reason: 'Matched suspicious-script indicators.',
                  extra: el('div', null,
                    evidenceBox('IP-hosted script URLs', suspiciousIpScriptExamples.slice(0, 5).map((u, idx) => {
                      const url = String(u || '');
                      if (!url) return null;
                      const link = el('a', { href: url, target: '_blank', rel: 'noreferrer', text: url });
                      return [String(idx + 1), link];
                    })),
                    evidenceBox('Inline indicators', suspiciousInlineIndicators.slice(0, 15).map((s, idx) => [String(idx + 1), String(s || '')])),
                  )
                } : null),
              checkLine('External Scripts', String(externalScripts), externalScripts > 0 ? 'info' : 'ok',
                externalScriptExamples.length ? {
                  reason: 'Third-party script(s) loaded.',
                  extra: evidenceBox('Examples', externalScriptExamples.slice(0, 10).map((u, idx) => {
                    const url = String(u || '');
                    if (!url) return null;
                    const link = el('a', { href: url, target: '_blank', rel: 'noreferrer', text: url });
                    return [String(idx + 1), link];
                  }))
                } : null),
              checkLine('Suspicious Api Calls', apiSuspicious ? 'true' : 'false', apiSuspicious ? 'warn' : 'ok',
                apiSuspicious ? {
                  reason: 'Inline scripts reference absolute URLs on external hosts or IPs.',
                  extra: evidenceBox('Examples', suspiciousApiCallExamples.slice(0, 10).map((u, idx) => {
                    const url = String(u || '');
                    if (!url) return null;
                    const link = el('a', { href: url, target: '_blank', rel: 'noreferrer', text: url });
                    return [String(idx + 1), link];
                  })),
                } : null),
            ], { tone: (suspiciousScripts > 0 || apiSuspicious) ? 'warn' : 'ok' }),
            analysisCard('Detectable Vulnerabilities', [
              checkLine('Open Redirects', openRedirects ? 'Possible' : 'None detected', openRedirects ? 'warn' : 'ok',
                openRedirects ? { reason: 'Potential redirect parameter pointing to an external URL.', extra: openRedirectExtra } : null),
              checkLine('Inner Html Usage', innerHtml ? 'Detected' : 'None detected', innerHtml ? 'warn' : 'ok',
                innerHtml ? {
                  reason: innerHtmlOccurrences
                    ? ('Found ' + innerHtmlOccurrences + ' occurrence(s) in inline scripts.')
                    : 'Found usage in inline scripts.',
                  extra: evidenceBox('Evidence', [
                    innerHtmlOccurrences ? ['occurrences', String(innerHtmlOccurrences)] : null,
                    ...(innerHtmlIndicators || []).slice(0, 10).map((s, idx) => ['keyword ' + String(idx + 1), String(s || '')]),
                  ]),
                } : null),
              checkLine('Eval Usage', evalUsage ? 'Detected' : 'None detected', evalUsage ? 'warn' : 'ok',
                evalUsage ? {
                  reason: evalOccurrences
                    ? ('Found ' + evalOccurrences + ' occurrence(s) in inline scripts.')
                    : 'Found usage in inline scripts.',
                  extra: evidenceBox('Evidence', [
                    evalOccurrences ? ['occurrences', String(evalOccurrences)] : null,
                    ...(evalIndicators || []).slice(0, 10).map((s, idx) => ['pattern ' + String(idx + 1), String(s || '')]),
                  ]),
                } : null),
            ], { tone: (openRedirects || innerHtml || evalUsage) ? 'warn' : 'ok' }),

            // --- Privacy & Tracking Group ---
            cardGroupLabel('Privacy & Tracking'),
            analysisCard('Tracking Features', [
              checkLine('Tracking Scripts', trackingScripts ? 'Detected' : 'None detected', trackingScripts ? 'warn' : 'ok',
                trackingScripts ? {
                  reason: 'Tracking resources and/or analytics calls detected.',
                  extra: el('div', null,
                    evidenceBox('Resources', trackingResourceExamples.slice(0, 10).map((item, idx) => {
                      if (!item || typeof item !== 'object') return null;
                      const kind = String(item.kind || 'resource');
                      const url = String(item.url || '');
                      const typ = String(item.type || '');
                      if (!url) return null;
                      const link = el('a', { href: url, target: '_blank', rel: 'noreferrer', text: url });
                      const value = typ ? el('span', null, link, ' ', el('span', { class: 'muted', text: '(' + typ + ')' })) : link;
                      return [kind, value];
                    })),
                    evidenceBox('Inline indicators', trackingInlineIndicators.slice(0, 10).map((s, idx) => [String(idx + 1), String(s || '')])),
                  )
                } : null),
              checkLine('Fingerprinting', fingerprinting ? 'Detected' : 'None detected', fingerprinting ? 'warn' : 'ok',
                fingerprinting ? {
                  reason: 'Fingerprinting-related APIs/libraries detected.',
                  extra: evidenceBox('Indicators', fingerprintingIndicators.slice(0, 10).map((s, idx) => [String(idx + 1), String(s || '')])),
                } : null),
            ], { tone: (trackingScripts || fingerprinting) ? 'warn' : 'ok' }),
          );

          // Generate summary bar after cards are built
          const summaryBar = securitySummaryBar(cards);

          const actions = externalScanActions(finalUrl);
          section('Security Analysis', el('div', null, summaryBar, cards, actions));
        }

        // --- Page Information ---
        const headerPairs = Array.isArray(dl && dl.response_headers) ? dl.response_headers : [];
        const screenshotUrl = pageInfo && pageInfo.screenshot_url ? String(pageInfo.screenshot_url) : '';
        const screenshotMeta = (pageInfo && typeof pageInfo.screenshot === 'object' && pageInfo.screenshot) ? pageInfo.screenshot : null;
        const title = pageInfo && pageInfo.title ? String(pageInfo.title) : '';
        const description = pageInfo && pageInfo.description ? String(pageInfo.description) : '';

        function screenshotPlaceholder(meta) {
          const m = (meta && typeof meta === 'object') ? meta : null;
          const status = (m && m.status) ? String(m.status) : '';
          const errRaw = (m && m.error) ? String(m.error) : '';
          const err = errRaw.replace(/\s+/g, ' ').trim();
          const shortErr = err.length > 140 ? (err.slice(0, 137) + '...') : err;

          if (status === 'disabled') return 'Screenshot capture is disabled (set CAPTURE_SCREENSHOTS=true)';
          if (status === 'failed') return shortErr ? ('Screenshot capture failed: ' + shortErr) : 'Screenshot capture failed';
          if (status === 'store_failed') return shortErr ? ('Screenshot store failed: ' + shortErr) : 'Screenshot store failed';
          return 'Screenshot not available';
        }

        // Categorize headers for better organization
        function categorizeHeaders(headers) {
          const categories = {
            security: { label: 'Security', headers: [] },
            caching: { label: 'Caching', headers: [] },
            content: { label: 'Content', headers: [] },
            other: { label: 'Other', headers: [] }
          };

          const securityHeaders = ['content-security-policy', 'content-security-policy-report-only', 'x-frame-options', 'x-xss-protection', 'x-content-type-options', 'strict-transport-security', 'permissions-policy', 'referrer-policy', 'cross-origin-opener-policy', 'cross-origin-embedder-policy', 'cross-origin-resource-policy'];
          const cachingHeaders = ['cache-control', 'expires', 'etag', 'last-modified', 'age', 'vary', 'pragma'];
          const contentHeaders = ['content-type', 'content-length', 'content-encoding', 'content-language', 'content-disposition', 'transfer-encoding'];

          for (const h of headers) {
            if (!h || typeof h !== 'object') continue;
            const name = h.name ? String(h.name).toLowerCase() : '';
            if (!name) continue;

            if (securityHeaders.includes(name)) {
              categories.security.headers.push(h);
            } else if (cachingHeaders.includes(name)) {
              categories.caching.headers.push(h);
            } else if (contentHeaders.includes(name)) {
              categories.content.headers.push(h);
            } else {
              categories.other.headers.push(h);
            }
          }
          return categories;
        }

        if (isTerminal && (headerPairs.length || screenshotUrl || title || description || screenshotMeta)) {
          // Page metadata cards
          const pageMeta = el('div', { class: 'page-meta' });
          if (title) {
            pageMeta.appendChild(el('div', { class: 'page-meta-item' },
              el('div', { class: 'page-meta-label', text: 'Page Title' }),
              el('div', { class: 'page-meta-value', text: title })
            ));
          }
          if (description) {
            pageMeta.appendChild(el('div', { class: 'page-meta-item' },
              el('div', { class: 'page-meta-label', text: 'Description' }),
              el('div', { class: 'page-meta-value', text: description })
            ));
          }

          // Categorized headers
          const categories = categorizeHeaders(headerPairs);
          const headerList = el('div', { class: 'headers-list' });

          for (const [catKey, cat] of Object.entries(categories)) {
            if (!cat.headers.length) continue;
            headerList.appendChild(el('div', { class: 'headers-category', text: cat.label }));
            for (const h of cat.headers) {
              const name = h.name ? String(h.name) : '';
              const value = h.value != null ? String(h.value) : '';
              headerList.appendChild(el('div', { class: 'header-row' },
                el('div', { class: 'header-name', text: name + ':' }),
                el('div', { class: 'header-value', text: value })
              ));
            }
          }

          const headersToggle = el('details', { class: 'mini-toggle' });
          const headersSummary = el('summary', { text: 'Show Response Headers (' + headerPairs.length + ')' });
          headersToggle.addEventListener('toggle', () => {
            headersSummary.textContent = headersToggle.open
              ? 'Hide Response Headers'
              : 'Show Response Headers (' + headerPairs.length + ')';
          });
          headersToggle.appendChild(headersSummary);
          headersToggle.appendChild(headerList);

          const left = el('div', null,
            (title || description) ? pageMeta : null,
            headerPairs.length ? headersToggle : null
          );

          const right = el('div', { class: 'screenshot' },
            el('div', { class: 'screenshot-label', text: 'Page Screenshot' }),
            screenshotUrl
              ? (() => {
                const holder = el('div', { class: 'placeholder', text: 'Loading screenshot…' });
                const img = el('img', { alt: 'Page screenshot', style: 'display:none' });

                getScreenshotObjectUrl(screenshotUrl).then(objectUrl => {
                  if (!objectUrl) throw new Error('no object url');
                  if (!img.isConnected) return;
                  img.src = objectUrl;
                  img.style.display = '';
                  if (holder.isConnected) holder.remove();
                }).catch(() => {
                  if (!holder.isConnected) return;
                  holder.textContent = 'Screenshot not available';
                });

                img.addEventListener('click', () => {
                  if (img.src) openImageModal(img.src);
                });

                return el('div', null, holder, img);
              })()
              : el('div', { class: 'placeholder', text: screenshotPlaceholder(screenshotMeta) })
          );

          section('Page Information', el('div', { class: 'split' }, left, right));
        }

        // --- Network Information ---
        const dns = Array.isArray(netInfo && netInfo.dns_addresses) ? netInfo.dns_addresses : [];
        const whois = (netInfo && typeof netInfo.whois === 'object' && netInfo.whois) ? netInfo.whois : null;

        // Calculate domain age helper
        function calculateDomainAge(creationDateStr) {
          try {
            const created = new Date(creationDateStr);
            if (isNaN(created.getTime())) return null;
            const now = new Date();
            const years = Math.floor((now - created) / (365.25 * 24 * 60 * 60 * 1000));
            if (years < 1) {
              const months = Math.floor((now - created) / (30.44 * 24 * 60 * 60 * 1000));
              return months + ' month' + (months !== 1 ? 's' : '') + ' old';
            }
            return years + ' year' + (years !== 1 ? 's' : '') + ' old';
          } catch (_) {
            return null;
          }
        }

        // Format ISO date string to readable format with timezone
        function formatWhoisDate(dateStr) {
          try {
            const d = new Date(dateStr);
            if (isNaN(d.getTime())) return String(dateStr);

            const options = {
              year: 'numeric',
              month: 'short',
              day: 'numeric',
              timeZone: 'UTC',
              timeZoneName: 'short'
            };
            return d.toLocaleDateString('en-US', options);
          } catch (_) {
            return String(dateStr);
          }
        }

        if (isTerminal && (dns.length || whois)) {
          const networkGrid = el('div', { class: 'network-grid' });

          // DNS Card
          if (dns.length) {
            const dnsCard = el('div', { class: 'network-card' });
            dnsCard.appendChild(el('div', { class: 'network-card-header' },
              el('div', { class: 'network-card-title' },
                el('span', { class: 'network-card-icon', text: '🌐' }),
                el('span', { text: 'DNS Addresses' })
              ),
              el('span', { class: 'network-card-badge', text: dns.length + ' IP' + (dns.length !== 1 ? 's' : '') })
            ));
            dnsCard.appendChild(el('div', { class: 'dns-grid' },
              ...dns.slice(0, 12).map(ip => el('div', { class: 'dns-item', text: String(ip) }))
            ));
            networkGrid.appendChild(dnsCard);
          }

          // WHOIS Card
          if (whois && (whois.registrar || whois.creation_date || whois.expiration_date || whois.error)) {
            const whoisCard = el('div', { class: 'network-card' });
            const domainAge = whois.creation_date ? calculateDomainAge(whois.creation_date) : null;

            whoisCard.appendChild(el('div', { class: 'network-card-header' },
              el('div', { class: 'network-card-title' },
                el('span', { class: 'network-card-icon', text: '📋' }),
                el('span', { text: 'WHOIS Information' })
              ),
              domainAge ? el('span', { class: 'domain-age', text: domainAge }) : null
            ));

            const whoisGrid = el('div', { class: 'whois-grid' });
            if (whois.registrar) {
              whoisGrid.appendChild(el('div', { class: 'whois-row' },
                el('span', { class: 'whois-label', text: 'Registrar' }),
                el('span', { class: 'whois-value', text: String(whois.registrar) })
              ));
            }
            if (whois.creation_date) {
              whoisGrid.appendChild(el('div', { class: 'whois-row' },
                el('span', { class: 'whois-label', text: 'Created' }),
                el('span', { class: 'whois-value highlight', title: String(whois.creation_date), text: formatWhoisDate(whois.creation_date) })
              ));
            }
            if (whois.expiration_date) {
              whoisGrid.appendChild(el('div', { class: 'whois-row' },
                el('span', { class: 'whois-label', text: 'Expires' }),
                el('span', { class: 'whois-value', title: String(whois.expiration_date), text: formatWhoisDate(whois.expiration_date) })
              ));
            }
            if (whois.error) {
              whoisGrid.appendChild(el('div', { class: 'whois-row' },
                el('span', { class: 'whois-label', text: 'Error' }),
                el('span', { class: 'whois-value', text: String(whois.error) })
              ));
            }
            whoisCard.appendChild(whoisGrid);
            networkGrid.appendChild(whoisCard);
          }

          section('Network Information', networkGrid);
        }

        if (blocks.length === 0) {
          summaryOutEl.appendChild(el('div', { class: 'muted', text: 'No data yet.' }));
          return;
        }
        for (const b of blocks) summaryOutEl.appendChild(b);
      }

      function renderRaw(resp) {
        const obj = resp || {};
        outEl.textContent = JSON.stringify(obj, null, 2);
      }

      function showSummary(obj) {
        lastSummary = obj;
        lastSummaryJobId = (obj && obj.job_id) ? obj.job_id : null;
        renderSummary(obj);
        setButtonsEnabled(true);
      }

      function showFull(obj) {
        lastFull = obj;
        lastSummary = obj;
        lastFullJobId = (obj && obj.job_id) ? obj.job_id : null;
        lastSummaryJobId = lastFullJobId;
        renderSummary(obj);
        if (activeTab === 'raw') renderRaw(obj);
        setButtonsEnabled(true);
      }

      function showPlaceholder() {
        renderSummary(lastSummary || lastFull || {});
        if (activeTab === 'raw') {
          outEl.textContent = JSON.stringify({ message: 'Raw JSON not loaded yet. Click "Check job" or switch tabs.' }, null, 2);
        }
        setButtonsEnabled(Boolean(lastSummary || lastFull));
      }

      function setActiveTab(next) {
        activeTab = next;
        const isSummary = next === 'summary';
        tabSummaryEl.setAttribute('aria-selected', isSummary ? 'true' : 'false');
        tabRawEl.setAttribute('aria-selected', isSummary ? 'false' : 'true');
        panelSummaryEl.classList.toggle('hidden', !isSummary);
        panelRawEl.classList.toggle('hidden', isSummary);

        if (!isSummary) {
          if (lastFull && (!currentJobId || lastFullJobId === currentJobId)) renderRaw(lastFull);
          else showPlaceholder();
        } else {
          renderSummary(lastSummary || lastFull || {});
        }
      }

      let _resizeTimer = null;
      window.addEventListener('resize', () => {
        if (_resizeTimer) clearTimeout(_resizeTimer);
        _resizeTimer = setTimeout(() => {
          renderSummary(lastSummary || lastFull || {});
        }, 120);
      });

      async function copyText(text) {
        try {
          await navigator.clipboard.writeText(text);
          showToast('Copied to clipboard', 'success', 2500);
        } catch (_) {
          const ta = el('textarea', { style: 'position:fixed;left:-1000px;top:-1000px;' });
          ta.value = text;
          document.body.appendChild(ta);
          ta.select();
          document.execCommand('copy');
          ta.remove();
          showToast('Copied to clipboard', 'success', 2500);
        }
      }

      function isProblemDetails(obj) {
        if (!obj || typeof obj !== 'object') return false;
        return typeof obj.type === 'string'
          && typeof obj.title === 'string'
          && (typeof obj.status === 'number' || typeof obj.status === 'string');
      }

      function hintForProblemCode(code) {
        const c = String(code || '').trim().toLowerCase();
        if (!c) return '';
        if (c === 'https_only') return 'Enter a valid HTTPS URL (e.g. https://example.com).';
        if (c === 'host_required') return 'Enter a valid URL (e.g. https://example.com).';
        if (c === 'dns_failed' || c === 'no_records') return 'Enter a valid public HTTPS URL (e.g. https://example.com).';
        if (c === 'localhost_not_allowed') return 'Use a public HTTPS URL (localhost is blocked).';
        if (c === 'non_public_ip' || c === 'direct_ip_not_public') return 'Use a publicly routable HTTPS URL (private IPs are blocked).';
        if (c === 'port_not_allowed') return 'Use the default HTTPS port (443).';
        if (c === 'userinfo_not_allowed') return 'Remove credentials from the URL.';
        return '';
      }

      function formatProblemMessage(problem) {
        const code = (problem && typeof problem.code === 'string') ? problem.code : '';
        const detailRaw = (problem && typeof problem.detail === 'string') ? problem.detail : '';
        const titleRaw = (problem && typeof problem.title === 'string') ? problem.title : '';
        let message = String(detailRaw || titleRaw || 'Request failed').trim();
        const hint = hintForProblemCode(code);
        if (hint && !message.toLowerCase().includes(hint.toLowerCase())) {
          if (!/[.?!]$/.test(message)) message += '.';
          message += ' ' + hint;
        }
        return message;
      }

      function formatApiError(err) {
        const data = err && err.data ? err.data : null;
        if (isProblemDetails(data)) {
          return { message: formatProblemMessage(data), problem: data };
        }
        const raw = data != null ? JSON.stringify(data) : '';
        return { message: raw || (err ? err.message : 'Unknown error'), problem: null };
      }

      async function api(path, method, body) {
        const headers = { 'content-type': 'application/json', 'accept': 'application/problem+json, application/json' };
        const key = apiKeyEl.value.trim();
        if (key) headers[API_KEY_HEADER] = key;
        const res = await fetch(path, {
          method: method,
          headers: headers,
          body: body ? JSON.stringify(body) : undefined
        });
        const text = await res.text();
        let data;
        try { data = JSON.parse(text); } catch (_) { data = { raw: text }; }
        if (!res.ok) {
          const err = new Error('HTTP ' + res.status);
          err.status = res.status;
          err.data = data;
          throw err;
        }
        return data;
      }

      async function apiBlob(path) {
        const headers = {};
        const key = apiKeyEl.value.trim();
        if (key) headers[API_KEY_HEADER] = key;
        const res = await fetch(path, { method: 'GET', headers });
        if (!res.ok) {
          const err = new Error('HTTP ' + res.status);
          err.status = res.status;
          throw err;
        }
        return await res.blob();
      }

      async function getScreenshotObjectUrl(screenshotUrl) {
        const url = String(screenshotUrl || '').trim();
        if (!url) return '';

        if (screenshotCache.has(url)) return screenshotCache.get(url);
        if (screenshotPending.has(url)) return await screenshotPending.get(url);

        const promise = (async () => {
          try {
            const blob = await apiBlob(url);
            const objectUrl = URL.createObjectURL(blob);
            screenshotCache.set(url, objectUrl);

            // Keep memory bounded.
            while (screenshotCache.size > 25) {
              const oldestKey = screenshotCache.keys().next().value;
              const oldestUrl = screenshotCache.get(oldestKey);
              if (oldestUrl) {
                try { URL.revokeObjectURL(oldestUrl); } catch (_) { }
              }
              screenshotCache.delete(oldestKey);
            }

            return objectUrl;
          } finally {
            screenshotPending.delete(url);
          }
        })();

        screenshotPending.set(url, promise);
        return await promise;
      }

      function formatWhen(iso) {
        if (!iso) return '';
        try { return dtf.format(new Date(iso)); } catch (_) { return iso; }
      }

      function formatRelativeTime(iso) {
        if (!iso) return '';
        try {
          const date = new Date(iso);
          const now = Date.now();
          const diff = now - date.getTime();
          const seconds = Math.floor(diff / 1000);
          const minutes = Math.floor(seconds / 60);
          const hours = Math.floor(minutes / 60);
          const days = Math.floor(hours / 24);

          if (seconds < 60) return 'just now';
          if (minutes < 60) return minutes === 1 ? '1 min ago' : minutes + ' mins ago';
          if (hours < 24) return hours === 1 ? '1 hour ago' : hours + ' hours ago';
          if (days < 7) return days === 1 ? 'yesterday' : days + ' days ago';
          return formatWhen(iso);
        } catch (_) {
          return formatWhen(iso);
        }
      }

      function statusKind(status) {
        if (status === 'completed') return 'ok';
        if (status === 'error' || status === 'blocked') return 'warn';
        return 'info';
      }

      function isTerminalStatus(status) {
        return status === 'completed' || status === 'error' || status === 'blocked';
      }

      function historyStatus(status) {
        const s = String(status || '').toLowerCase();
        if (s === 'completed') return { label: 'completed', kind: 'ok', title: 'completed' };
        if (s === 'error') return { label: 'error', kind: 'warn', title: 'error' };
        if (s === 'blocked') return { label: 'blocked', kind: 'warn', title: 'blocked' };
        const title = s ? s : 'pending';
        return { label: 'pending', kind: 'info', title };
      }

      function renderHistory() {
        const apiKey = apiKeyEl.value.trim();
        const filter = (historyFilterEl.value || '').trim().toLowerCase();
        const order = (historyOrderEl && historyOrderEl.value) ? String(historyOrderEl.value) : 'recent';

        historyBodyEl.textContent = '';

        const showTableMessage = (text) => {
          const cell = el('td', { class: 'muted', colspan: '5', text: text });
          historyBodyEl.appendChild(el('tr', null, cell));
        };

        if (!apiKey) {
          showTableMessage('Enter your API key to load history.');
          historyPageInfoEl.textContent = '';
          historyPrevEl.disabled = true;
          historyNextEl.disabled = true;
          return;
        }

        if (historyLoading && (!Array.isArray(history) || history.length === 0)) {
          showTableMessage('Loading history…');
          historyPageInfoEl.textContent = '';
          historyPrevEl.disabled = true;
          historyNextEl.disabled = true;
          return;
        }

        if (historyLoadError && (!Array.isArray(history) || history.length === 0)) {
          showTableMessage('Unable to load history: ' + historyLoadError);
          historyPageInfoEl.textContent = '';
          historyPrevEl.disabled = true;
          historyNextEl.disabled = true;
          return;
        }

        const parseMs = (iso) => {
          if (!iso) return 0;
          const t = Date.parse(iso);
          return Number.isFinite(t) ? t : 0;
        };

        let items = Array.isArray(history) ? history.slice() : [];
        items = items.filter(item => {
          if (!item) return false;
          if (!filter) return true;
          const hay = (String(item.url || '') + ' ' + String(item.job_id || '')).toLowerCase();
          return hay.indexOf(filter) >= 0;
        });

        items.sort((a, b) => {
          const aMs = parseMs(a.submitted_at || a.scanned_at || a.updated_at || a.last_checked_at);
          const bMs = parseMs(b.submitted_at || b.scanned_at || b.updated_at || b.last_checked_at);
          if (order === 'oldest') return aMs - bMs;
          return bMs - aMs; // recent (default)
        });

        const total = items.length;
        const totalPages = Math.max(1, Math.ceil(total / HISTORY_PAGE_SIZE));
        if (historyPage > totalPages) historyPage = totalPages;
        if (historyPage < 1) historyPage = 1;

        historyPrevEl.disabled = historyPage <= 1;
        historyNextEl.disabled = historyPage >= totalPages;

        const updated = historyLastLoadedAt ? formatWhen(historyLastLoadedAt) : '';
        historyPageInfoEl.textContent = `Page ${historyPage}/${totalPages} · ${total} job${total === 1 ? '' : 's'}${updated ? ' · Updated ' + updated : ''}`;

        if (total === 0) {
          const msg = filter ? 'No matching scans.' : 'No scans yet. Start one to see it here.';
          showTableMessage(msg);
          return;
        }

        const start = (historyPage - 1) * HISTORY_PAGE_SIZE;
        const pageItems = items.slice(start, start + HISTORY_PAGE_SIZE);

        for (const item of pageItems) {
          const job = item.job_id || '';
          const shortJob = job ? (job.slice(0, 8) + '…') : '';
          const rawStatus = String(item.status || '');
          const hs = historyStatus(rawStatus);

          const whenIso = item.submitted_at || item.updated_at || item.last_checked_at || '';
          const when = formatRelativeTime(whenIso);
          const whenFull = formatWhen(whenIso);

          const badge = makeBadge(hs.kind, hs.label);
          badge.title = hs.title;

          const deduped = Boolean(item.deduped);
          const visibility = String(item.visibility || '').trim().toLowerCase();

          const whenTitleParts = [];
          if (item.submitted_at) whenTitleParts.push('Submitted: ' + formatWhen(item.submitted_at));
          if (item.scanned_at) whenTitleParts.push('Scanned: ' + formatWhen(item.scanned_at));
          const whenTitle = whenTitleParts.length ? whenTitleParts.join('\n') : whenFull;

          const url = String(item.url || '').trim();
          const urlLink = url
            ? el('a', { href: url, target: '_blank', rel: 'noreferrer', text: url })
            : el('span', { class: 'muted', text: '(no url)' });

          const badges = el('div', { class: 'badge-row' }, badge);
          if (deduped) {
            const scannedLabel = item.scanned_at ? formatRelativeTime(item.scanned_at) : '';
            const cacheBadge = makeBadge('info', 'cache');
            cacheBadge.title = scannedLabel ? ('Cache hit (scanned ' + scannedLabel + ')') : 'Cache hit';
            badges.appendChild(cacheBadge);
          } else if (visibility === 'private') {
            const privateBadge = makeBadge('info', 'private');
            privateBadge.title = 'Not cached (private)';
            badges.appendChild(privateBadge);
          }

          const actions = el('div', { class: 'job-actions' });

          const viewBtn = el('button', { type: 'button', text: 'View' });
          viewBtn.disabled = !job;
          viewBtn.addEventListener('click', async () => {
            if (!job) return;
            if (!canFetchJobFromView(job)) {
              setStatus('info', 'Please wait a moment before viewing this job again.');
              return;
            }
            viewFetchInFlightJobs.add(String(job));
            viewBtn.disabled = true;
            currentJobId = job;
            currentRunId = String(item.run_id || '').trim() || null;
            setButtonsEnabled(true);
            try {
              await refreshJob(job, true);
              maybeStartPollingFallback(job);
            } finally {
              viewFetchInFlightJobs.delete(String(job));
              if (viewBtn.isConnected) viewBtn.disabled = !job;
            }
          });

          const useBtn = el('button', { type: 'button', text: 'Use URL' });
          useBtn.disabled = !url;
          useBtn.addEventListener('click', () => {
            if (!url) return;
            urlEl.value = normalizeUrlInput(url);
            urlEl.focus();
            setStatus('info', 'Loaded URL from history');
          });

          actions.appendChild(viewBtn);
          actions.appendChild(useBtn);

          // Job ID cell with copy button
          const jobCode = el('code', { text: shortJob, title: job });
          const copyJobBtn = el('button', { type: 'button', class: 'copy-job-btn', title: 'Copy job ID', 'aria-label': 'Copy job ID', text: '📋' });
          copyJobBtn.addEventListener('click', async () => {
            if (!job) return;
            try {
              await navigator.clipboard.writeText(job);
              copyJobBtn.textContent = '✓';
              copyJobBtn.classList.add('copied');
              setTimeout(() => {
                copyJobBtn.textContent = '📋';
                copyJobBtn.classList.remove('copied');
              }, 1500);
            } catch (e) {
              showToast('Failed to copy job ID', 'error');
            }
          });
          const jobIdCell = el('span', { class: 'job-id-cell' }, jobCode, copyJobBtn);

          const row = el(
            'tr',
            null,
            el('td', { class: 'timestamp-cell', 'data-label': 'When', text: when, title: whenTitle }),
            el('td', { class: 'url-cell', 'data-label': 'URL' }, urlLink),
            el('td', { class: 'nowrap', 'data-label': 'Job' }, jobIdCell),
            el('td', { class: 'nowrap', 'data-label': 'Status' }, badges),
            el('td', { class: 'nowrap', 'data-label': 'Actions' }, actions)
          );
          historyBodyEl.appendChild(row);
        }
      }

      async function refreshJob(jobId, showOutput) {
        if (!jobId) return null;
        const isCurrent = !currentJobId || currentJobId === jobId;
        if (isCurrent) {
          setStatus('info', 'Fetching status for ' + jobId + '...');
        }
        try {
          const view = activeTab === 'raw' ? 'full' : 'summary';
          const s = await api('/scan/' + jobId + '?view=' + encodeURIComponent(view), 'GET');
          const now = new Date().toISOString();
          // Use upsertHistory so it creates the entry if it doesn't exist (e.g., from deep-link)
          upsertHistory({
            job_id: jobId,
            run_id: s.run_id || undefined,
            url: s.summary?.url || s.summary?.download?.requested_url || undefined,
            status: s.status,
            error: s.error || null,
            deduped: Boolean(s.deduped),
            visibility: s.visibility || undefined,
            submitted_at: s.submitted_at || undefined,
            scanned_at: s.scanned_at || null,
            last_checked_at: now
          });
          if (isCurrent) {
            currentRunId = s.run_id || currentRunId;
            if (showOutput) {
              if (view === 'full') showFull(s);
              else showSummary(s);
            } else {
              // Still update summary so the UI stays current while polling.
              showSummary(s);
            }
            setStatus(statusKind(s.status), 'Job ' + jobId + ' is ' + s.status);
          }
          return s;
        } catch (e) {
          const info = formatApiError(e);
          if (isCurrent) {
            setStatus('bad', info.message);
            if (showOutput) showSummary({ status: 'error', error: info.message, problem: info.problem || null });
          }
          return null;
        }
      }

      async function loadFull(jobId) {
        if (!jobId) return null;
        try {
          const full = await api('/scan/' + jobId + '?view=full', 'GET');
          lastFull = full;
          lastFullJobId = (full && full.job_id) ? full.job_id : jobId;
          if (activeTab === 'raw' && (!currentJobId || currentJobId === jobId)) {
            renderRaw(full);
            setButtonsEnabled(true);
          }
          return full;
        } catch (_) {
          return null;
        }
      }

      function stopLiveUpdates(opts) {
        const keepDesired = Boolean(opts && opts.keepDesired);
        if (liveConnectTimer) {
          clearTimeout(liveConnectTimer);
          liveConnectTimer = null;
        }
        if (liveFallbackPollTimer) {
          clearTimeout(liveFallbackPollTimer);
          liveFallbackPollTimer = null;
        }
        if (pubsubReconnectTimer) {
          clearTimeout(pubsubReconnectTimer);
          pubsubReconnectTimer = null;
        }
        if (pubsubSocket) {
          intentionalSocketCloses.add(pubsubSocket);
          try { pubsubSocket.close(); } catch (_) { }
        }
        pubsubSocket = null;
        pubsubReconnectMs = 0;
        if (!keepDesired) pubsubDesired = false;
      }

      function isLiveConnected() {
        return Boolean(pubsubSocket && pubsubSocket.readyState === WebSocket.OPEN);
      }

      function isLiveActive() {
        if (!pubsubSocket) return false;
        return pubsubSocket.readyState === WebSocket.OPEN || pubsubSocket.readyState === WebSocket.CONNECTING;
      }

      function patchHistoryByRunId(runId, patch) {
        const target = String(runId || '').trim();
        if (!target) return [];
        const updated = [];
        for (const item of (Array.isArray(history) ? history : [])) {
          if (!item || !item.job_id) continue;
          if (String(item.run_id || '').trim() !== target) continue;
          patchHistory(String(item.job_id), patch);
          updated.push(String(item.job_id));
        }
        return updated;
      }

      function handleLiveMessage(data) {
        if (!data || typeof data !== 'object') return;
        const runId = String(data.run_id || '').trim();
        const status = data.status ? String(data.status) : '';
        if (!status || !runId) return;
        const prevStatus = lastLiveStatusByRun.get(runId);
        if (prevStatus === status && isTerminalStatus(status)) return;
        lastLiveStatusByRun.set(runId, status);

        const patch = {
          run_id: runId,
          status: status,
          error: data.error || null,
          scanned_at: data.scanned_at || null,
          last_checked_at: new Date().toISOString()
        };

        let affectedJobs = patchHistoryByRunId(runId, patch);
        if ((!affectedJobs || !affectedJobs.length) && currentJobId && currentRunId && String(currentRunId) === runId) {
          upsertHistory(Object.assign({ job_id: currentJobId }, patch));
          affectedJobs = [currentJobId];
        }

        if (currentJobId && affectedJobs.includes(String(currentJobId))) {
          setStatus(statusKind(status), 'Job ' + currentJobId + ' is ' + status);
          if (isTerminalStatus(status)) {
            refreshJob(currentJobId, true);
          }
        }
      }

      function connectLiveUpdates(url) {
        if (!url) return Promise.resolve(false);
        if (pubsubSocket) {
          intentionalSocketCloses.add(pubsubSocket);
          try { pubsubSocket.close(); } catch (_) { }
        }
        return new Promise((resolve) => {
          let ws = null;
          let opened = false;
          let settled = false;

          function finish(ok) {
            if (settled) return;
            settled = true;
            resolve(Boolean(ok));
          }

          try {
            ws = new WebSocket(url, WEBPUBSUB_SUBPROTOCOL);
          } catch (_) {
            scheduleLiveReconnect();
            finish(false);
            return;
          }

          pubsubSocket = ws;
          const openTimeout = setTimeout(() => {
            if (opened) return;
            try { ws.close(); } catch (_) { }
            finish(false);
          }, 4000);

          ws.onopen = () => {
            opened = true;
            clearTimeout(openTimeout);
            pubsubReconnectMs = 0;
            if (liveFallbackPollTimer) {
              clearTimeout(liveFallbackPollTimer);
              liveFallbackPollTimer = null;
            }
            cancelPolling();
            finish(true);
          };
          ws.onmessage = (evt) => {
            let msg;
            try { msg = JSON.parse(evt.data); } catch (_) { return; }
            if (!msg || msg.type !== 'message') return;
            if (msg.from && msg.from !== 'group') return;
            let data = msg.data;
            if (typeof data === 'string') {
              try { data = JSON.parse(data); } catch (_) { }
            }
            handleLiveMessage(data);
          };
          ws.onerror = () => {
            if (!opened) finish(false);
          };
          ws.onclose = () => {
            clearTimeout(openTimeout);
            const intentional = intentionalSocketCloses.has(ws);
            if (intentional) intentionalSocketCloses.delete(ws);
            if (pubsubSocket === ws) pubsubSocket = null;
            if (!opened) {
              finish(false);
              return;
            }
            if (intentional) return;
            if (pubsubDesired) {
              if (liveFallbackPollTimer) clearTimeout(liveFallbackPollTimer);
              liveFallbackPollTimer = setTimeout(() => {
                liveFallbackPollTimer = null;
                if (!isLiveConnected() && currentJobId) startPoll(currentJobId);
              }, 4000);
              scheduleHistoryRefresh(800);
              scheduleLiveReconnect();
            }
          };
        });
      }

      function maybeShowTerminalToast(jobId, status) {
        const id = String(jobId || '').trim();
        const s = String(status || '').toLowerCase();
        if (!id || !isTerminalStatus(s)) return false;
        if (terminalToastByJob.get(id) === s) return false;
        terminalToastByJob.set(id, s);
        return true;
      }

      function clearTerminalToast(jobId) {
        const id = String(jobId || '').trim();
        if (!id) return;
        terminalToastByJob.delete(id);
      }

      function maybeStartPollingFallback(jobId) {
        const id = String(jobId || '').trim();
        if (!id) return;
        if (!WEBPUBSUB_ENABLED) {
          startPoll(id);
          return;
        }
        if (isLiveActive()) return;
        startPoll(id);
      }

      function shouldReconnectLive(opts) {
        const forceReconnect = Boolean(opts && opts.forceReconnect);
        if (!forceReconnect && isLiveActive()) return false;
        return true;
      }

      function canFetchJobFromView(jobId) {
        const id = String(jobId || '').trim();
        if (!id) return false;
        if (viewFetchInFlightJobs.has(id)) return false;
        const now = Date.now();
        const last = Number(viewLastFetchAt.get(id) || 0);
        if ((now - last) < VIEW_FETCH_THROTTLE_MS) return false;
        viewLastFetchAt.set(id, now);
        return true;
      }

      function scheduleLiveReconnect(ms) {
        if (!WEBPUBSUB_ENABLED) return;
        if (!pubsubDesired) return;
        if (!apiKeyEl.value.trim()) return;
        if (isLiveActive()) return;
        if (pubsubReconnectTimer) return;
        const baseInput = Number(ms || 0);
        const base = baseInput > 0
          ? baseInput
          : (pubsubReconnectMs ? Math.min(pubsubReconnectMs * 2, 15000) : 1500);
        pubsubReconnectMs = base;
        pubsubReconnectTimer = setTimeout(() => {
          pubsubReconnectTimer = null;
          if (!pubsubDesired) return;
          startLiveUpdates({ silent: true, forceReconnect: true });
        }, pubsubReconnectMs);
      }

      function scheduleLiveConnect(ms) {
        if (liveConnectTimer) clearTimeout(liveConnectTimer);
        liveConnectTimer = setTimeout(() => {
          liveConnectTimer = null;
          if (!apiKeyEl.value.trim()) {
            stopLiveUpdates();
            return;
          }
          startLiveUpdates({ silent: true });
        }, Math.max(0, Number(ms || 0)) || 300);
      }

      async function startLiveUpdates(opts) {
        if (!WEBPUBSUB_ENABLED) return false;
        const silent = opts && opts.silent;
        const key = apiKeyEl.value.trim();
        if (!key) return false;
        pubsubDesired = true;
        if (!shouldReconnectLive(opts)) return true;
        stopLiveUpdates({ keepDesired: true });
        try {
          const res = await api('/pubsub/negotiate-user', 'POST', {});
          const url = res && res.url ? String(res.url) : '';
          if (!url) throw new Error('No Web PubSub URL');
          if (!silent) setStatus('info', 'Connecting live updates...');
          const connected = await connectLiveUpdates(url);
          if (!connected) throw new Error('Web PubSub socket unavailable');
          return true;
        } catch (_) {
          stopLiveUpdates({ keepDesired: true });
          scheduleLiveReconnect();
          return false;
        }
      }

      function cancelPolling() {
        pollToken += 1;
        activePolls.clear();
      }

      function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

      async function pollJob(jobId, token) {
        const deadline = Date.now() + (MAX_POLL_SECONDS * 1000);
        while (Date.now() < deadline) {
          if (token !== pollToken) return null;
          const s = await refreshJob(jobId, true);
          if (token !== pollToken) return null;
          if (s && (s.status === 'completed' || s.status === 'error' || s.status === 'blocked')) {
            // Preload full payload for the Raw JSON tab once the job is terminal.
            if (!lastFull || lastFullJobId !== jobId) {
              await loadFull(jobId);
            }
            return s;
          }
          if (token !== pollToken) return null;
          await sleep(4000);
        }
        throw new Error('Timed out waiting for result');
      }

      function startPoll(jobId) {
        const id = String(jobId || '').trim();
        if (!id || activePolls.has(id)) return;
        cancelPolling();
        const runAtStart = String(currentRunId || '').trim();
        const token = pollToken;
        const pollPromise = (async () => {
          try {
            const result = await pollJob(id, token);
            if (token !== pollToken) return;
            if (result && currentJobId === id) {
              const status = String(result.status || '').toLowerCase();
              if (!maybeShowTerminalToast(id, status)) return;
              if (status === 'completed') {
                showToast('Scan completed successfully!', 'success');
                setStatus('ok', 'Completed');
              } else if (status === 'blocked') {
                showToast('Scan blocked by upstream site', 'warn');
                setStatus('warn', 'Blocked');
              } else {
                showToast('Scan finished with errors', 'error');
                setStatus('bad', 'Error');
              }
            }
          } catch (e) {
            if (token !== pollToken) return;
            if (currentJobId === id) {
              const runNow = String(currentRunId || '').trim();
              if (runAtStart && runNow && runAtStart !== runNow) return;
              const info = formatApiError(e);
              showToast(info.message, 'error', 6000);
              setStatus('bad', info.message);
            }
          }
        })();
        activePolls.set(id, pollPromise);
        pollPromise.finally(() => activePolls.delete(id));
      }

      async function startScan() {
        if (isSubmitting) return;
        let target = '';
        try {
          target = toHttpsUrl(urlEl.value);
        } catch (e) {
          showToast(e ? e.message : 'Only HTTPS URLs are allowed', 'error');
          setStatus('bad', e ? e.message : 'Only HTTPS URLs are allowed');
          return;
        }
        if (!target) {
          showToast('Enter a URL to scan', 'warn');
          setStatus('bad', 'Enter a URL');
          urlEl.focus();
          return;
        }

        isSubmitting = true;
        setStatus('info', 'Submitting scan...');
        showSummary({
          status: 'submitting',
          error: null,
          submitted_at: new Date().toISOString(),
          scanned_at: null,
          summary: { url: target }
        });
        setButtonsEnabled(false);
        setButtonLoading(startEl, true);
        checkCurrentEl.disabled = true;

        try {
          const submit = await api('/scan', 'POST', { url: target, type: 'url' });
          lastFull = null;
          lastFullJobId = null;
          showSummary(submit);
          const submitStatus = String(submit && submit.status ? submit.status : '').toLowerCase();
          const submitDeduped = Boolean(submit && submit.deduped);

          currentJobId = submit.job_id || null;
          currentRunId = submit.run_id || null;
          setButtonsEnabled(true);

          if (currentJobId) {
            const now = new Date().toISOString();
            upsertHistory({
              job_id: currentJobId,
              run_id: submit.run_id || undefined,
              url: target,
              status: submit.status || 'queued',
              error: null,
              deduped: submitDeduped,
              visibility: submit.visibility || undefined,
              submitted_at: now,
              scanned_at: null,
              last_checked_at: null
            });
            clearTerminalToast(currentJobId);
            showToast('Scan submitted! Waiting for results...', 'info', 3000);
            urlEl.value = '';
          }

          if (!currentJobId) {
            showToast('No job ID returned from server', 'error');
            setStatus('bad', 'No job_id returned');
            return;
          }

          if (isTerminalStatus(submitStatus)) {
            await refreshJob(currentJobId, true);
            if (submitDeduped && submitStatus === 'completed') {
              setStatus('ok', 'Cache hit; showing existing scan result');
              showToast('Cache hit: reused existing completed scan', 'info', 3000);
            } else {
              setStatus(statusKind(submitStatus), 'Job ' + currentJobId + ' is ' + submitStatus);
            }
            return;
          }

          const live = await startLiveUpdates({ silent: true });
          if (live) {
            if (submitDeduped) {
              setStatus('info', 'Using existing run; listening for updates...');
            } else {
              setStatus('info', 'Job queued; listening for updates...');
            }
          } else {
            if (submitDeduped) {
              setStatus('info', 'Using existing run; polling for updates...');
            } else {
              setStatus('info', 'Job queued; polling for results...');
            }
            maybeStartPollingFallback(currentJobId);
          }
        } catch (e) {
          const info = formatApiError(e);
          showToast(info.message, 'error', 6000);
          setStatus('bad', info.message);
          showSummary({ status: 'error', error: info.message, summary: { url: target }, problem: info.problem || null });
        } finally {
          isSubmitting = false;
          setButtonLoading(startEl, false);
          startEl.disabled = false;
          setButtonsEnabled(true);
        }
      }

      function init() {
        const stored = localStorage.getItem(LS.apiKey) || localStorage.getItem(LS.legacyApiKey) || '';
        apiKeyEl.value = stored;
        if (stored && !localStorage.getItem(LS.apiKey)) localStorage.setItem(LS.apiKey, stored);

        // Show saved indicator if API key exists
        if (stored) apiKeySavedEl.style.display = 'inline-flex';

        // API key visibility toggle
        apiKeyToggleEl.addEventListener('click', () => {
          const isPassword = apiKeyEl.type === 'password';
          apiKeyEl.type = isPassword ? 'text' : 'password';
          apiKeyToggleEl.innerHTML = isPassword
            ? '<svg class="eye-icon" viewBox="0 0 24 24"><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"/><line x1="1" y1="1" x2="23" y2="23"/></svg>'
            : '<svg class="eye-icon" viewBox="0 0 24 24"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>';
          apiKeyToggleEl.title = isPassword ? 'Hide API key' : 'Show API key';
        });

        apiKeyEl.addEventListener('input', () => {
          localStorage.setItem(LS.apiKey, apiKeyEl.value);
          apiKeySavedEl.style.display = apiKeyEl.value.trim() ? 'inline-flex' : 'none';
          stopLiveUpdates();
          cancelPolling();
          scheduleHistoryRefresh(450);
          if (apiKeyEl.value.trim()) scheduleLiveConnect(500);
        });
        const stripSchemeIfPresent = () => {
          const next = normalizeUrlInput(urlEl.value);
          if (next !== urlEl.value) urlEl.value = next;
        };
        urlEl.addEventListener('blur', stripSchemeIfPresent);
        urlEl.addEventListener('paste', () => setTimeout(stripSchemeIfPresent, 0));

        // Keyboard shortcut: Ctrl/Cmd + Enter to submit scan
        urlEl.addEventListener('keydown', (e) => {
          if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
            e.preventDefault();
            if (!startEl.disabled && !isSubmitting) {
              startScan();
            }
          }
        });

        // Also allow Enter to submit when URL field is focused
        urlEl.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' && !e.metaKey && !e.ctrlKey && !e.shiftKey) {
            e.preventDefault();
            if (!startEl.disabled && !isSubmitting) {
              startScan();
            }
          }
        });

        history = [];
        renderHistory();
        if (apiKeyEl.value.trim()) {
          refreshHistoryFromServer({ silent: true });
          startLiveUpdates({ silent: true });
        }
        lastSummary = {};
        lastFull = null;
        showPlaceholder();
        setButtonsEnabled(false);

        // Check for ?job= parameter to deep-link to a specific scan
        const urlParams = new URLSearchParams(window.location.search);
        const jobParam = urlParams.get('job');
        if (jobParam && jobParam.trim()) {
          currentJobId = jobParam.trim();
          // Check if API key is available
          const apiKey = apiKeyEl.value.trim();
          if (!apiKey) {
            setStatus('warn', 'Enter your API key above, then click "Check job" to load job ' + currentJobId);
            showToast('Enter your API key to load the scan results', 'warn', 5000);
            setButtonsEnabled(true);
            return;
          }
          setStatus('info', 'Loading job ' + currentJobId + '...');
          refreshJob(currentJobId, true).then(result => {
            if (result) {
              setButtonsEnabled(true);
              if (result.status === 'completed' || result.status === 'error' || result.status === 'blocked') {
                loadFull(currentJobId);
              }
            }
          });
          startLiveUpdates({ silent: true }).then(live => {
            if (!live) maybeStartPollingFallback(currentJobId);
          });
        }
      }

      startEl.addEventListener('click', startScan);
      checkCurrentEl.addEventListener('click', async () => {
        const jobId = String(currentJobId || '').trim();
        if (!jobId) return;
        if (!canFetchJobFromView(jobId)) {
          setStatus('info', 'Please wait a moment before checking this job again.');
          return;
        }
        await refreshJob(jobId, true);
        maybeStartPollingFallback(jobId);
      });
      clearHistoryEl.addEventListener('click', () => {
        const ok = window.confirm('This will permanently clear your URL scan history for this API key. Continue?');
        if (!ok) return;
        clearScreenshotCache();
        clearHistoryServer();
      });
      historyFilterEl.addEventListener('input', () => {
        resetHistoryPaging();
        renderHistory();
      });
      historyOrderEl.addEventListener('change', () => {
        resetHistoryPaging();
        renderHistory();
      });
      historyPrevEl.addEventListener('click', () => {
        if (historyPage > 1) {
          historyPage -= 1;
          renderHistory();
        }
      });
      historyNextEl.addEventListener('click', () => {
        historyPage += 1;
        renderHistory();
      });
      tabSummaryEl.addEventListener('click', () => setActiveTab('summary'));
      tabRawEl.addEventListener('click', async () => {
        setActiveTab('raw');
        if (currentJobId && (!lastFull || lastFullJobId !== currentJobId)) {
          await refreshJob(currentJobId, true);
        }
      });

      copyJsonEl.addEventListener('click', async () => {
        const text = activeTab === 'raw'
          ? (outEl.textContent || '')
          : JSON.stringify((lastSummary && lastSummary.problem) ? lastSummary.problem : ((lastSummary && lastSummary.summary) ? lastSummary.summary : (lastSummary || {})), null, 2);
        if (text) await copyText(text);
      });
      copyJson2El.addEventListener('click', async () => {
        const text = activeTab === 'raw'
          ? (outEl.textContent || '')
          : JSON.stringify((lastSummary && lastSummary.problem) ? lastSummary.problem : ((lastSummary && lastSummary.summary) ? lastSummary.summary : (lastSummary || {})), null, 2);
        if (text) await copyText(text);
      });

      init();
      setActiveTab('summary');
    })();
  </script>
</body>

</html>
