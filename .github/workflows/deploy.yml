name: Deploy
on:
  workflow_dispatch:
    inputs:
      mode:
        description: Deployment mode (full or infra-only)
        required: true
        default: full
      region:
        description: Azure region (e.g. eastus)
        required: true
        default: eastus
      prefix:
        description: Resource prefix (lowercase; used for most resource names)
        required: true
        default: devsecopsaca
      resource_group:
        description: Resource group name (e.g. rg-devsecops-aca)
        required: true
        default: rg-devsecops-aca
      tfstate_sa:
        description: Terraform state storage account name (globally unique; lowercase letters/numbers only)
        required: true
        default: stdevsecopsacatfstate
      tfstate_container:
        description: Terraform state container name
        required: true
        default: tfstate
      tfstate_key:
        description: Terraform state blob name
        required: true
        default: devsecopsaca.tfstate
      queue_name:
        description: Service Bus queue name
        required: true
        default: tasks
      kv_secret_reader_object_ids_json:
        description: Optional JSON array of Entra object IDs to grant Key Vault Secrets User (e.g. ["<oid1>","<oid2>"]).
        required: false
        default: ""

concurrency:
  # Prevent deploy/destroy/keda runs from overlapping for the same environment
  group: aca-${{ inputs.prefix }}-${{ inputs.resource_group }}
  # If an App Deploy (CD) run is already in progress for this environment, cancel it so infra deploy can proceed.
  cancel-in-progress: true

# NOTE: Keep shared inputs in sync with destroy.yml to avoid configuration drift.
# (mode is deploy-only)
env:
  MODE: ${{ inputs.mode }}
  REGION: ${{ inputs.region }}
  PREFIX: ${{ inputs.prefix }}
  RG: ${{ inputs.resource_group }}
  TFSTATE_SA: ${{ inputs.tfstate_sa }}
  TFSTATE_CONTAINER: ${{ inputs.tfstate_container }}
  TFSTATE_KEY: ${{ inputs.tfstate_key }}
  QUEUE_NAME: ${{ inputs.queue_name }}
  KV_SECRET_READER_OBJECT_IDS_JSON: ${{ inputs.kv_secret_reader_object_ids_json || vars.ACA_KV_SECRET_READER_OBJECT_IDS_JSON || secrets.ACA_KV_SECRET_READER_OBJECT_IDS_JSON || '' }}

jobs:
  infra-bootstrap:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    permissions: { id-token: write, contents: read }

    steps:
      - uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - uses: hashicorp/setup-terraform@v3

      - name: Cache Terraform plugins
        uses: actions/cache@v5
        with:
          path: ${{ runner.temp }}/.terraform-plugin-cache
          key: terraform-${{ runner.os }}-${{ hashFiles('infra/.terraform.lock.hcl') }}
          restore-keys: |
            terraform-${{ runner.os }}-

      - name: Bootstrap infra (foundation + state + apply)
        shell: bash
        env:
          AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          TF_PLUGIN_CACHE_DIR: ${{ runner.temp }}/.terraform-plugin-cache
        run: |
          mkdir -p "$TF_PLUGIN_CACHE_DIR"
          bash scripts/gha/deploy_infra_bootstrap.sh

      - name: Write infra-bootstrap summary
        if: always()
        shell: bash
        run: |
          python3 .github/scripts/deploy_summary.py infra-bootstrap

  build-and-push:
    needs: [infra-bootstrap]
    if: ${{ inputs.mode != 'infra-only' }}
    runs-on: ubuntu-latest
    timeout-minutes: 20
    permissions: { id-token: write, contents: read }
    outputs:
      acr_login_server: ${{ steps.acr.outputs.login_server }}
      api_image: ${{ steps.acr.outputs.login_server }}/${{ env.PREFIX }}-api:${{ github.sha }}
      worker_image: ${{ steps.acr.outputs.login_server }}/${{ env.PREFIX }}-worker:${{ github.sha }}
      clamav_image: ${{ steps.acr.outputs.login_server }}/${{ env.PREFIX }}-clamav:${{ github.sha }}

    steps:
      - uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get ACR login server
        id: acr
        run: |
          ACR="$(az acr show -g "${{ env.RG }}" -n "${{ env.PREFIX }}acr" --query loginServer -o tsv)"
          echo "login_server=${ACR}" >> $GITHUB_OUTPUT

      - name: ACR login
        run: az acr login --name $(echo "${{ steps.acr.outputs.login_server }}" | cut -d. -f1)

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build & push API
        uses: docker/build-push-action@v6
        with:
          context: ./app
          file: app/api/Dockerfile
          push: true
          tags: ${{ steps.acr.outputs.login_server }}/${{ env.PREFIX }}-api:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build & push Worker
        uses: docker/build-push-action@v6
        with:
          context: ./app
          file: app/worker/Dockerfile.sidecar
          push: true
          tags: ${{ steps.acr.outputs.login_server }}/${{ env.PREFIX }}-worker:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build & push ClamAV
        uses: docker/build-push-action@v6
        with:
          context: ./app
          file: app/clamav/Dockerfile
          push: true
          tags: ${{ steps.acr.outputs.login_server }}/${{ env.PREFIX }}-clamav:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Write build-push summary
        if: always()
        shell: bash
        env:
          ACR_LOGIN_SERVER: ${{ steps.acr.outputs.login_server }}
          API_IMAGE: ${{ steps.acr.outputs.login_server }}/${{ env.PREFIX }}-api:${{ github.sha }}
          WORKER_IMAGE: ${{ steps.acr.outputs.login_server }}/${{ env.PREFIX }}-worker:${{ github.sha }}
          CLAMAV_IMAGE: ${{ steps.acr.outputs.login_server }}/${{ env.PREFIX }}-clamav:${{ github.sha }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          python3 .github/scripts/deploy_summary.py build-push

  create-apps:
    needs: [build-and-push]
    if: ${{ inputs.mode != 'infra-only' }}
    runs-on: ubuntu-latest
    timeout-minutes: 30
    permissions: { id-token: write, contents: read }

    steps:
      - uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - uses: hashicorp/setup-terraform@v3

      - name: Cache Terraform plugins
        uses: actions/cache@v5
        with:
          path: ${{ runner.temp }}/.terraform-plugin-cache
          key: terraform-${{ runner.os }}-${{ hashFiles('infra/.terraform.lock.hcl') }}
          restore-keys: |
            terraform-${{ runner.os }}-

      - name: Create/update apps + smoke/e2e tests
        id: deploy
        shell: bash
        env:
          IMAGE_TAG: ${{ github.sha }}
          TF_PLUGIN_CACHE_DIR: ${{ runner.temp }}/.terraform-plugin-cache
        run: |
          mkdir -p "$TF_PLUGIN_CACHE_DIR"
          # Run deploy script and capture outputs for summary
          bash scripts/gha/deploy_create_apps_and_test.sh | tee deploy_output.log
          
          # Extract key values from Terraform and Azure CLI for summary
          API_URL="$(terraform -chdir=infra output -raw fastapi_url 2>/dev/null || echo "")"
          echo "API_URL=${API_URL}" >> "$GITHUB_ENV"
          
          # Get replica counts
          API_REPLICAS="$(az containerapp replica list -g "$RG" -n "${PREFIX}-api" --query "length(@)" -o tsv 2>/dev/null || echo "—")"
          FETCHER_REPLICAS="$(az containerapp replica list -g "$RG" -n "${PREFIX}-fetcher" --query "length(@)" -o tsv 2>/dev/null || echo "—")"
          WORKER_REPLICAS="$(az containerapp replica list -g "$RG" -n "${PREFIX}-worker" --query "length(@)" -o tsv 2>/dev/null || echo "—")"
          echo "API_REPLICAS=${API_REPLICAS}" >> "$GITHUB_ENV"
          echo "FETCHER_REPLICAS=${FETCHER_REPLICAS}" >> "$GITHUB_ENV"
          echo "WORKER_REPLICAS=${WORKER_REPLICAS}" >> "$GITHUB_ENV"
          
          # Get queue depths
          SBNS="${PREFIX}-sbns"
          TASKS_QUEUE_ACTIVE="$(az servicebus queue show -g "$RG" --namespace-name "$SBNS" -n "$QUEUE_NAME" --query "countDetails.activeMessageCount" -o tsv 2>/dev/null || echo "—")"
          TASKS_QUEUE_DEAD="$(az servicebus queue show -g "$RG" --namespace-name "$SBNS" -n "$QUEUE_NAME" --query "countDetails.deadLetterMessageCount" -o tsv 2>/dev/null || echo "—")"
          SCAN_QUEUE_ACTIVE="$(az servicebus queue show -g "$RG" --namespace-name "$SBNS" -n "${QUEUE_NAME}-scan" --query "countDetails.activeMessageCount" -o tsv 2>/dev/null || echo "—")"
          SCAN_QUEUE_DEAD="$(az servicebus queue show -g "$RG" --namespace-name "$SBNS" -n "${QUEUE_NAME}-scan" --query "countDetails.deadLetterMessageCount" -o tsv 2>/dev/null || echo "—")"
          echo "TASKS_QUEUE_ACTIVE=${TASKS_QUEUE_ACTIVE}" >> "$GITHUB_ENV"
          echo "TASKS_QUEUE_DEAD=${TASKS_QUEUE_DEAD}" >> "$GITHUB_ENV"
          echo "SCAN_QUEUE_ACTIVE=${SCAN_QUEUE_ACTIVE}" >> "$GITHUB_ENV"
          echo "SCAN_QUEUE_DEAD=${SCAN_QUEUE_DEAD}" >> "$GITHUB_ENV"

      - name: Determine test status
        id: test_status
        if: always()
        shell: bash
        run: |
          # Parse deploy output for health and E2E status
          HEALTH_STATUS="unknown"
          E2E_STATUS="unknown"
          E2E_JOB_ID=""
          
          if [ -f deploy_output.log ]; then
            if grep -q "API is healthy" deploy_output.log; then
              HEALTH_STATUS="healthy"
            elif grep -q "API did not become healthy" deploy_output.log; then
              HEALTH_STATUS="failed"
            fi
            
            if grep -q "E2E scan completed" deploy_output.log; then
              E2E_STATUS="completed"
            elif grep -q "E2E scan failed" deploy_output.log; then
              E2E_STATUS="error"
            elif grep -q "Timed out waiting for scan" deploy_output.log; then
              E2E_STATUS="timeout"
            fi
            
            # Extract job_id if present
            E2E_JOB_ID="$(grep -o 'job_id=[^ ]*' deploy_output.log | head -1 | cut -d= -f2 || true)"
          fi
          
          echo "HEALTH_STATUS=${HEALTH_STATUS}" >> "$GITHUB_ENV"
          echo "E2E_STATUS=${E2E_STATUS}" >> "$GITHUB_ENV"
          echo "E2E_JOB_ID=${E2E_JOB_ID}" >> "$GITHUB_ENV"

      - name: Write workflow summary
        if: always()
        shell: bash
        env:
          IMAGE_TAG: ${{ github.sha }}
        run: |
          python3 .github/scripts/deploy_summary.py create-apps
